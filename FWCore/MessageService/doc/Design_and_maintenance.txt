   Design, operation and maintenance manual for MessageLogger/MessageService
   -------------------------------------------------------------------------

------------------------------
General Work Flow of a Message
------------------------------

The effect of a user issuing a  LogInfo (for example) is that 
an error object is formed and sent to the ErrorLog, which has
been configured to filter these in some way and to dispatch 
the messages to one or more destinations.  This section will 
outline the steps involved.  

The user code may be running in opne or more threads, each of 
which might issue messages.  We will call these the client side.
In any event, a single entity, the MessageLoggerScribe, picks 
up on these messages and forwards them to the looger one at a time;
this prevents interlacing of message information from different threads.
We call the thread running MessageLoggerScribe -- see How the Message
Service Starts Up -- the server side.  All user programatic interaction
is on the client side, but the configuration (driven by the .cfg file)
is dealt with on the server side. 

The path looks like this (each step is detailed below):

------------------------------------------------
Client side:						          MessageDrop
  LogInfo						              |
    --> MessageSender (owning ErrorObj)  <----------------- run/event +
        operator << --> ErrorObj::operator<<
        --> end of the LogInfo line
            --> ~LogInfo --> ~MessageSender
	                      --> MessageLoggerQ::LOG(ErrorObj)			      
------------------------------------------------    |
						MessageLoggerScribe::run()
						consume(opcode, operand)  <--+ 
				 log(ErrorObj)	<--  |                       |
              errorlog(ErrorObj) <--                 |                       |
     ELoutput <--	                             |                       |
	      				        delete ErrorObj              |
				 		     |                       |
						     +-----------------------+
Server side:
------------------------------------------------
						     
LogInfo is a functor -- a class that has an operator() so that
it can look like a function.   It has one  data member - an 
auto_ptr to a MessageSender, which is named ap.  When you say

LogInfo("myCategory") << x; 

the constructor of LogInfo constructs a new MessageSender specifying that
this is at severity level ELinfo, and that the category is myCategory.
When the << x is encountered, that merely sends << x to the MessageSender.

In the line        LogInfo("myCategory") << x; 
one has created a **temporary** instance of LogInfo -- this gets 
destructed upon completion of the statement.  The whole working of LogInfo 
is in that destruction:  Since LogInfo has an auto_ptr to the Message
Sender, when LogInfo goes away, the auto_ptr goes away, and this causes
a delete of the MessageSender.  The destructor of MessageSender is where
all the action -- at the client side -- happens.  

The MessageSender instance owns an ErrorObj on the heap; this can be viewed
as a receptacle for the severity and category information and a collection
of items sent in by operator<<.   The ctor of MessageSender makes a new
ErrorObj -- AND  MessageSender NEVER DELETES THAT ErrorObj!! --
Instead, the destructor of MessageSender [which, we will remember, is
invoked as soon as the LogInfo("myCategory") << x;  statement has been 
executed] interacts with the servier side, placing in motion events that
will lead to the pointer to this ErrorObj to be used and ultimately
deleted by code on the server side.  The ErrorObj is on the heap, so this 
pointer remains meaningful in the server side it will be used in. 

The interaction of MessageSender with the server side consists of two steps.  

First, it uses the MessageDrop instance to supply the module
  and run/event context.   [There is a separate discussion below about the
  MessageDrop.]  The module and context go into the ErrorObj.
 
Second, it invokes the static LOG method of MessageLoggerQ, supplying the
  pointer to the ErrorObj.

Now we leave the client side and go to the server side, which picks up the 
LOG_A_MESSAGE entry in the course of a consume(opcode,operand) call on the 
MessageLoggerQ.  The run() method of MessageLoggerScribe has an eternal
do, which continually tries to consume from this queue (consume() sleeps on 
the queue being empty).

The method log() is passed the pointer to the ErrorObj.  log() gets
a reference to the ELcontextSupplier from the administrator, and sets
the context to that context remembered in the ErrorObj.  (This is necessary
since the run/event of the message issuer is known to the client thread, 
having been provided by the before-module and before-event callbacks of the 
message **service** running in the **client** thread, so this information had 
needed to cross the client/server boundary.) 

log() then parses the categories string and (if there are multiple categories)
invokes the ErrorLog for this object for each category in the string.

ErrorLog is in the ErrorLogger code; we are not documenting this code here.
The effect is to shop the ErrorObj to every destination; in each case the
code for that destination (normally ELoutput) will apply the limits and
thresholds, format the message, add header information, and output the message.
 
Finally, the completion of the do in MessageLoggerScribe::run() deletes the
ErrorObj -- completing the promise made when it was passed responsibility for
this heap-resident object.

---------------
The MessageDrop
---------------

The purpose of the message drop is to convey framework information to the
point-of-invocation where a message is issued.  The functions issuing 
messages may not naturally have access to the ModuleDescription or the
EventID (which contains the run and event numbers) or the list (prepared
by configuration in MessageLoggerScrivbe) of debug-enabled modules.  The
process of preparing a message requires this information.

In discussing how the MessageDrop works, we will pay attention to the facts
that the MessageLoggerScript will be running in a distinct thread from the
code issuing the message, and that there may be several threads processing
events, each issuing messages independantly.  MessageDrop is a 
thread-specific singleton.

The following files interact with MessageDrop:
    In the MessageLogger package:
	MessageDrop.h		MessageDrop.cc
	MessageLogger.h 	MessageSender.cc
    In the MessageService package:
    	MessageLogger.cc
	
MessageDrop.h defines a singleton pattern.  The (private) default ctor
	      initializes the public data:
		 ModuleName is ""
		 runEvent is "pre-events"
		 debugEnabled is true 
	      There is a public instance() method
	     
MessageDrop.cc refines that to be a thread-specific singleton pattern.
	       This is accomplished by replacing the static bare pointer
	       to MessageDrop which would have been present in an ordinary
	       singleton, with a boost::thread_specific_ptr<MessageDrop>.
	       The latter is a object that may contain several pointers,
	       but only one is accessible in this thread.
	       The instance() method calls drops.get() to obtain that
	       pointer.  Just as for a usual singleton, if the pointer
	       is null, it sets the pointer to a new MessageDrop.  Thus
	       instance() will always return a pointer to the unique 
	       MessageDrop for this thread.
	       
	       Note that the server side has no way to influence or access
	       the MessageDrop for a specific thread; thus any information
	       present in the drop and needed by the server needs to be 
	       added into the ErrorObject hat will cross the client/server
	       boundary.    

MessageLogger.h uses the MessageDrop in the LogDebug macro to learn the 
		value of debugEnabled.  If debugEnabled is set to false, 
		then the effect of LogDebug is to immediately return.

MessageSender.cc gets the instance of MessageDrop to find out the 
		 moduleName and the runEvent.  It then places these into
		 the ErrorObject it is forming to pass over to the 
		 server.  This is how the correct event number, for example,
		 finds its way accurately into that other thread even if
		 yet other threads are also issuing messages.

MessageLogger.cc is responsible for filling the data fields of the 
		 MessageDrop with needed information.  MessageLogger.cc
		 is in the MessageService, to avoid introducing
		 a dependency on ModuleDescription into MessageLogger.
		 But it is not part of the MessageLoggerScribe thread; 
		 it is part of the same thread as the issuing message.
		 Thus when it sets up information, that info is available
		 for stuffing into the ErrorObj or use in deciding whether
		 to react to a LogDebug.  The information provided is:
      In PostBeginJob it says that we are BeforeEvents and in no module.
      In PreEventProcessing it fills in the run and event.
      In PostEventProcessing it notes that we are between events.		 
      In PreModule it fills in the module name, and sets value of debugEnabled. 
		 To determine the value to set for debugEnabled, 
		 two bools and a vector of module names come into play;
		 these are all universal (that is, not thread-specific)
		 and are established when the MessageLogger object in
		 MessageService is constructed, by getting the vString 
		 debugModules:
		 anyDebugEnabled_     is a global scope variable instantiated
		 		      as false in MessageLogger.cc.  In the 
				      ctor of MessageLogger, this is set to
				      true if debugModules is non-empty.
		 everyDebugEnabled_   is a global scope variable instantiated
		 		      as false in MessageLogger.cc.  In the 
				      ctor of MessageLogger, this is set to
				      true if nay one of debugModules is "*".
		 debugEnabledModules_ contains the specified debugModules.
		 If debugEnabled is set to false, then the effect of LogDebug
		 used during that module is to immediately return.
		
A subtlety arose concerning the MessageDrop in circumstances where 
the framework's event processing structure were not in play.  In 
particular, if preModule were never called, then debugEnabled would
remain whatever value it had on construction of the MessageDrop --
originally, the value was left uninitialized.   Now it is initialized to 
true.  Also, in the ctor for MessageLogger (in MessageLogger.cc) if
debugModules is empty, we change debugEnabled MessageDrop's debugEnabled
to false.

----------
purge_mode
----------

What happends if the act of logging a message (on the server side) throws
an exception?  This logic is implemented in MessageLoggerScribe.cc.

If the exception is a cms::Exception, then for the first 5 times, output
is sent to cerr containing the explanation e.what().  After five such
exceptions, or for any exception not inherited from cms::Exception, the
system is placed into purge_mode, after which no further message
processing will occur.

====================
ErrorLogger Workings
====================

Although for the most part the ErrorLogger is not a product of CMS-related
work (it is instead taken to be a given starting point for the underpinning
of MessageLogger) some tailoring was done in response to CMS-requested
features.  The workings directly impacted by this tailoring are appropriate
to dilscuss in this document. 

------------------------------------
Establishment and Checking of Limits
------------------------------------

Limits (and here, we also include intervals in the sense of skipping every N
occurences of some type of message) are established in code involving
  ELadminstrator.cc (just forwarding to ELdestinations)
  ELdest_control.cc
  ELdestination.cc
and at the MessageLogger level, the establishing calls are initiated by 
commands from the configure_dest() method in MessageLoggerScribe.cc.

There is a wide variety of logical ways the limit and interval can be 
determined.  Although in the ErrorLogger the concept of limits and thresholds
is tied to individual distributions, the MessageLogger wrapping allows a
configuratoin file to specify overall defaults - in each case, values
specific to a destination take precedence over overall defaults.
In order of precedence, the rules are:

1) If for a particular destination the category has had a specific limit
   (interval) set, then that limit (interval) is used.
   
2) If an overall default limit (interval) has been established for this 
   specific category, then [unless (1) holds] the limit (interval) 
   for this category is taken to be that default value. 
   
3) If for a particular destination the severity of the message has had 
   a specific (interval) set, then that limit (interval) is used.  Note 
   that for categories explicitly mentioned in the default, this case
   is not applied, since case (2) would take precedence.

4) If an overall default limit (interval) has been established for this 
   severity level, then [unless (1), (2), or (3) holds] that limit (interval) 
   is used.
   
5) If for a particular destination a wildcard catgory ("*") has been assigned
   a limit (interval) and neither the the category nor the severity of this 
   message has had a limit (interval) set, then the limit (interval) used
   will be that wildcard value.
   
6) If (1) thru (5) do not hold for a particular destination, but a wildcard 
   catgory has been assigned a limit (interval) in the overall default, then 
   this is used as the wildcard limit (interval) for that destination.
   
7) If none of the above conditions hold, then the super-default is no limit,
   and an inteval that causes no skipping.  Internally, a value of -1 indicates
   an infinte limit, and also can indicate an interval that was never given 
   a value.  

The logic implementing these rules appears in ELmap.h and .cc (in the 
MessageLogger module) and ELlimitTable.h and .cc (in MessageService).
The rules for deciding -- given the limit, interval, timespan and then 
number of messages in this category already issued -- whether to react to 
a message are discussed below.

ELlimitTable is responsible for holding three types of information:
Established default-type (severity and wildcard) limits applicable 
to a specific destination, limits applicable to specific categories 
for this destination, and counts of how many times a category has been 
sent to this destination (and how many have been skipped since the last 
reaction).   Each destination owns its own ELlimitsTable,l named limits.  
The third type of information is kept in a map of extended ID (that is, 
severity and category combination) versus CountAndLimit -- the latter is 
a class defined in ELmap.h holding the information that changes with each 
new message.  (The ELstatistics destination also makes use of this class; 
subtleties about methods such as wipe() and zero() apply to statistics and 
we won't worry about them for now.)

This third type of information is kept in a member of ELlimitsTable named
counts, and this is the key information.  The static information of the first
two types is established by calls to ELdestControl methods (for example, 
setLimit()).   At first glance, it would appear that the information in
ELlimitsTable's data members limits is a partial replicate of the limit
(and timespan and interval) information in the counts data member.  This
is not the case, however:  While counts is indexed by the full extended id,
limits is accessed by just the id (the category, without regard to the
severity level).  If different default limits for different severities have
been set, then for categories not explicitly controlled, these values will be
distinct.

       {Unfortunately, the data member limits, which is an ELmap_limits, 
       has the same name as the limits data member of ELdestination, which 
       is an ELlimitsTable.  There is ample potential for confusion in that.
       Here, we will try to enhance clarity by using the simple name limits
       to always refer to the data member of ELlimitsTable -- when we need 
       to talk about the data member of ELdestination we will always call it
       ELdestination::limits.}

The information in limits, and the static information in counts is established 
gradually (one further complication is that both are limited in size to some
large tableLimit; this is unimportant for CMS).  The wat this happens is that
the destination derived classes (for example ELoutput) call, for each message,
the add() method of their ELlimitsTable, in a line reading:

  if ( ! limits.add( msg.xid() )       )  return false;

This add method has three purposes:  It returns a bool telling whether or not
to react to this particular message, it adds this message xid and id to the 
appropriate tables, and it updates the dynamic information in counts.  
The sequence is as follows:

1) See if the xid is in counts -- if so, the apppropriate static limit, 
   interval, and timespan will be in the mapped CountAndLimit struct,
   and there will be no need to recompute them.
   
2) If this xid is not yet in counts, see if the category is in limits -- if so,
   the appropriate counts struct can be formed by using the precedence rules
   above to combine the limit and interval found in limits  along with the 
   severityLimits and severityIntervals arrays found in the ELlimitsTable.  
   Along the way, the limits map for this category is filled in; that won't
   change even if a diffeerent severity i the same category is encountered.
   And now the xid is in counts (unless counts has grown too large).
   
3) Now xid will normally be in counts:  invoke add for that xid to update
   the dynamic information and find out whether to react to this message.
   
The rules for deciding whether to react to a message are implemented in 
CountAndLimit::add(xid), and are as follows:

0) If the timespan has been exceeded since the last message, reset both n 
   (to 0) and the skipped value (to interval) because we want fresh outputs
   reacting to this message.
   
1) See if the message is OK with regards to the interval:  If we have already
   skipped interval messages, we want to react to this one.  (Note that this
   implies skipped should be initialized to interval, so that the very first 
   one will be reacted to.)  Assuming we are OK with regards to the interval...
   
2) See if the message is OK with regards to the limit:  If the limit is -1,
   if n is below the limit, or if n is above the limit by 2**q times the limit,
   we will possibly react to the message.
   
3) If we are OK on both accounts, we will react to this message.  In that case,
   skipped should be reset to zero.
   
   

   



