   Design, operation and maintenance manual for MessageLogger/MessageService
   -------------------------------------------------------------------------

------------------------------
General Work Flow of a Message
------------------------------

The effect of a user issuing a  LogInfo (for example) is that 
an error object is formed and sent to the ErrorLog, which has
been configured to filter these in some way and to dispatch 
the messages to one or more destinations.  This section will 
outline the steps involved.  

The user code may be running in opne or more threads, each of 
which might issue messages.  We will call these the client side.
In any event, a single entity, the MessageLoggerScribe, picks 
up on these messages and forwards them to the looger one at a time;
this prevents interlacing of message information from different threads.
We call the thread running MessageLoggerScribe -- see How the Message
Service Starts Up -- the server side.  All user programatic interaction
is on the client side, but the configuration (driven by the .cfg file)
is dealt with on the server side. 

The path looks like this (each step is detailed below):

------------------------------------------------
Client side:						          MessageDrop
  LogInfo						              |
    --> MessageSender (owning ErrorObj)  <----------------- run/event +
        operator << --> ErrorObj::operator<<
        --> end of the LogInfo line
            --> ~LogInfo --> ~MessageSender
	                      --> MessageLoggerQ::LOG(ErrorObj)			      
------------------------------------------------    |
						MessageLoggerScribe::run()
						consume(opcode, operand)  <--+ 
				 log(ErrorObj)	<--  |                       |
              errorlog(ErrorObj) <--                 |                       |
     ELoutput <--	                             |                       |
	      				        delete ErrorObj              |
				 		     |                       |
						     +-----------------------+
Server side:
------------------------------------------------
						     
LogInfo is a functor -- a class that has an operator() so that
it can look like a function.   It has one  data member - an 
auto_ptr to a MessageSender, which is named ap.  When you say

LogInfo("myCategory") << x; 

the constructor of LogInfo constructs a new MessageSender specifying that
this is at severity level ELinfo, and that the category is myCategory.
When the << x is encountered, that merely sends << x to the MessageSender.

In the line        LogInfo("myCategory") << x; 
one has created a **temporary** instance of LogInfo -- this gets 
destructed upon completion of the statement.  The whole working of LogInfo 
is in that destruction:  Since LogInfo has an auto_ptr to the Message
Sender, when LogInfo goes away, the auto_ptr goes away, and this causes
a delete of the MessageSender.  The destructor of MessageSender is where
all the action -- at the client side -- happens.  

The MessageSender instance owns an ErrorObj on the heap; this can be viewed
as a receptacle for the severity and category information and a collection
of items sent in by operator<<.   The ctor of MessageSender makes a new
ErrorObj -- AND  MessageSender NEVER DELETES THAT ErrorObj!! --
Instead, the destructor of MessageSender [which, we will remember, is
invoked as soon as the LogInfo("myCategory") << x;  statement has been 
executed] interacts with the servier side, placing in motion events that
will lead to the pointer to this ErrorObj to be used and ultimately
deleted by code on the server side.  The ErrorObj is on the heap, so this 
pointer remains meaningful in the server side it will be used in. 

The interaction of MessageSender with the server side consists of two steps.  

First, it uses the MessageDrop instance to supply the module
  and run/event context.   [There is a separate discussion below about the
  MessageDrop.]  The module and context go into the ErrorObj.
 
Second, it invokes the static LOG method of MessageLoggerQ, supplying the
  pointer to the ErrorObj.

Now we leave the client side and go to the server side, which picks up the 
LOG_A_MESSAGE entry in the course of a consume(opcode,operand) call on the 
MessageLoggerQ.  The run() method of MessageLoggerScribe has an eternal
do, which continually tries to consume from this queue (consume() sleeps on 
the queue being empty).

The method log() is passed the pointer to the ErrorObj.  log() gets
a reference to the ELcontextSupplier from the administrator, and sets
the context to that context remembered in the ErrorObj.  (This is necessary
since the run/event of the message issuer is known to the client thread, 
having been provided by the before-module and before-event callbacks of the 
message **service** running in the **client** thread, so this information had 
needed to cross the client/server boundary.) 

log() then parses the categories string and (if there are multiple categories)
invokes the ErrorLog for this object for each category in the string.

ErrorLog is in the ErrorLogger code; we are not documenting this code here.
The effect is to shop the ErrorObj to every destination; in each case the
code for that destination (normally ELoutput) will apply the limits and
thresholds, format the message, add header information, and output the message.
 
Finally, the completion of the do in MessageLoggerScribe::run() deletes the
ErrorObj -- completing the promise made when it was passed responsibility for
this heap-resident object.

---------------
The MessageDrop
---------------

The purpose of the message drop is to convey framework information to the
point-of-invocation where a message is issued.  The functions issuing 
messages may not naturally have access to the ModuleDescription or the
EventID (which contains the run and event numbers) or the list (prepared
by configuration in MessageLoggerScrivbe) of debug-enabled modules.  The
process of preparing a message requires this information.

In discussing how the MessageDrop works, we will pay attention to the facts
that the MessageLoggerScript will be running in a distinct thread from the
code issuing the message, and that there may be several threads processing
events, each issuing messages independantly.  MessageDrop is a 
thread-specific singleton.

The following files interact with MessageDrop:
    In the MessageLogger package:
	MessageDrop.h		MessageDrop.cc
	MessageLogger.h 	MessageSender.cc
    In the MessageService package:
    	MessageLogger.cc
	
MessageDrop.h defines a singleton pattern.  The (private) default ctor
	      initializes the public data:
		 ModuleName is ""
		 runEvent is "pre-events"
		 debugEnabled is true 
	      There is a public instance() method
	     
MessageDrop.cc refines that to be a thread-specific singleton pattern.
	       This is accomplished by replacing the static bare pointer
	       to MessageDrop which would have been present in an ordinary
	       singleton, with a boost::thread_specific_ptr<MessageDrop>.
	       The latter is a object that may contain several pointers,
	       but only one is accessible in this thread.
	       The instance() method calls drops.get() to obtain that
	       pointer.  Just as for a usual singleton, if the pointer
	       is null, it sets the pointer to a new MessageDrop.  Thus
	       instance() will always return a pointer to the unique 
	       MessageDrop for this thread.
	       
	       Note that the server side has no way to influence or access
	       the MessageDrop for a specific thread; thus any information
	       present in the drop and needed by the server needs to be 
	       added into the ErrorObject hat will cross the client/server
	       boundary.    

MessageLogger.h uses the MessageDrop in the LogDebug macro to learn the 
		value of debugEnabled.  If debugEnabled is set to false, 
		then the effect of LogDebug is to immediately return.

MessageSender.cc gets the instance of MessageDrop to find out the 
		 moduleName and the runEvent.  It then places these into
		 the ErrorObject it is forming to pass over to the 
		 server.  This is how the correct event number, for example,
		 finds its way accurately into that other thread even if
		 yet other threads are also issuing messages.

MessageLogger.cc is responsible for filling the data fields of the 
		 MessageDrop with needed information.  MessageLogger.cc
		 is in the MessageService, to avoid introducing
		 a dependency on ModuleDescription into MessageLogger.
		 But it is not part of the MessageLoggerScribe thread; 
		 it is part of the same thread as the issuing message.
		 Thus when it sets up information, that info is available
		 for stuffing into the ErrorObj or use in deciding whether
		 to react to a LogDebug.  The information provided is:
      In PostBeginJob it says that we are BeforeEvents and in no module.
      In PreEventProcessing it fills in the run and event.
      In PostEventProcessing it notes that we are between events.		 
      In PreModule it fills in the module name, and sets value of debugEnabled. 
		 To determine the value to set for debugEnabled, 
		 two bools and a vector of module names come into play;
		 these are all universal (that is, not thread-specific)
		 and are established when the MessageLogger object in
		 MessageService is constructed, by getting the vString 
		 debugModules:
		 anyDebugEnabled_     is a global scope variable instantiated
		 		      as false in MessageLogger.cc.  In the 
				      ctor of MessageLogger, this is set to
				      true if debugModules is non-empty.
		 everyDebugEnabled_   is a global scope variable instantiated
		 		      as false in MessageLogger.cc.  In the 
				      ctor of MessageLogger, this is set to
				      true if nay one of debugModules is "*".
		 debugEnabledModules_ contains the specified debugModules.
		 If debugEnabled is set to false, then the effect of LogDebug
		 used during that module is to immediately return.
		
A subtlety arose concerning the MessageDrop in circumstances where 
the framework's event processing structure were not in play.  In 
particular, if preModule were never called, then debugEnabled would
remain whatever value it had on construction of the MessageDrop --
originally, the value was left uninitialized.   Now it is initialized to 
true.  Also, in the ctor for MessageLogger (in MessageLogger.cc) if
debugModules is empty, we change debugEnabled MessageDrop's debugEnabled
to false.

==========
purge_mode
==========

What happends if the act of logging a message (on the server side) throws
an exception?  This logic is implemented in MessageLoggerScribe.cc.

If the exception is a cms::Exception, then for the first 5 times, output
is sent to cerr containing the explanation e.what().  After five such
exceptions, or for any exception not inherited from cms::Exception, the
system is placed into purge_mode, after which no further message
processing will occur.
