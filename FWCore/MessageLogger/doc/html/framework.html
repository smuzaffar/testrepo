<title>
	Frameworker's Basics of Error Loggers
</title>
<body bgcolor=FFFFFFFF>
<center>
<h1>
The ZOOM ErrorLogger Package:
<p>
<font color=red>
	Frameworker's Basics <br> of Setting up and Using Error Loggers
</font>
</h1>
</center>

<ul>
<li> <a href="#howlog"> How the frameworker sets up for logging </a> 
<li> 
<a href="#errlog"> How the Module (or Package) Sets Up errlog </a> 
<li> 
<a href="#howcontext"> ELcontextSupplier: 
	How the run and event numbers are indicated </a> 
<li> 
<a href="#threshlim"> Basics of Thresholds and Limits </a> 
<li> 
<a href="#modulefilter"> Filtering by Module or Multiple Modules </a> 
<li> 
<a href="#discardThreshold"> Rapid Discarding Below a Severity </a> 
<li> 
<a href="#debugVerbosity"> Establishing Debug Verbosity Levels </a> 
<li> 
<a href="#abort"> Controlling abort and exit() behavior </a> 
<li> 
<a href="#checking"> Checking on errors </a> 
<li> 
<a href="#stats"> Obtaining error statistics summaries </a> 
<li> 
<a href="#clear"> Clearing statistics and/or limits </a> 
</ul>
<p>
More esoteric details may be found in 
<a href="further.html"> Further Options for the Frameworker </a>
<hr>

<a name="howlog">
<h3> How the frameworker sets up for logging </h3>
</a>

   The ErrorLog objects that modules set up and that users see require that an 
   <b>ELadministrator</b> exist.  
	This encapsulates all the framework control over 
   how logging is done; in particular, the ELadministrator holds the 
   information as to what destinations should be used, and the way to get 
   context information when needed.
<p>
   The framework, outside the context of any ordinary module, should get
   an instance by invoking the ELadministrator::instance() method.  It will
   then use methods of this to establish how to get context information,
   and to attach various ELdestination sinks.
<p>
   So first the framework instantiates the ELadministrator:

<font color=blue>
<pre>
  #include "ErrorLogger/ELadministrator.h"
  ZM_USING_NAMESPACE( zmel ) /* using zmel; */

  ELadministrator * logger = ELadministrator::instance();
</font>
</pre>


<a name="indexELcontextSupplier"> </a> 
Next the framework provides the <b>ELcontextSupplier</b>, which the logger
will use when messages are logged to find out context such as run and event
numbers.  
This is done by 
creating a class derived from <b>ELcontextSupplier</b>,
and overriding the pure
virtual methods such as context().  
An instance of this class is passed to
logger.setContextSupplier().

<font color=blue>
<pre>
  MyContextObj contx;  // See below for how the derived context supplier
                       // looks.
  logger->setContextSupplier (contx);
</pre>
</font>

   Providing a context supplier is optional; it provides a way for the logger 
   to get at the run and event numbers when an error is logged.  If no supplier
   is provided, no run/event information will be associated with messages.  
   Further details are given below in <a href="#howcontext">
	ELcontextSupplier: How the run and event numbers are indicated.</a>

<p>


The frameworker may also declare the name of the overall process (or job,
or node in a farm situation).  When an error is logged, this name will go 
into the message.  This could be used to distinguish among many cooperating 
nodes which share the same output for destinations.

<font color=blue>
<pre>
  logger->setProcess( "PCfarm81" );
</pre>
</font>

<a name="indexattach"> </a>
<p>
Having instantiated logger and told it how to get context information,
the framework must attach one or more destinations -- sinks for the messages
and statistics to be sent to.  An error logger with no sinks is probably
useless.

<p>
   The logged information can go to each destination attached to the logger.
   But not every message will be acted on by every destination; each is 
   subject to thresholds and limits, as discussed below in <a href="#threshlim">
   Basics of Thresholds and Limits</a>, and possibly by 
   <a href="#modulefilter"> module filtering</a> 
   and/or <a href="#debugVerbosity">debugging verbosity level</a>.

<p>
   Three classes derived from ELdestination are provided by the ErrorLogger
   package:
<ul>
    <li> <b>ELoutput</b> is constructed taking an ostream, and is the typical 
	way to associate a log with either cout, cerr, or an ofstream for 
	a file.
     It has two forms of constructors:
<font color=blue>
<pre>
  ELoutput xx(ostream &);  // Log to An ostream (e.g. cerr)
  ELoutput xx("xfile");    // Log to the file named.
</pre>
</font>
	<ul>
	The form taking a file name is mostly a convenience, since 
	one could have opened an ofstream for that file, 
	and supplied that ofstream to the first constructor.
	</ul>
<p>
     <li> <b>ELstatistics </b> is a table of message frequencies and sample 
	contexts, which contains methods for generating run summaries.  
	Although when a summary is requested one specifies a stream or
	destination, the constructor of ELstatistics can take an ostream, 
	to which unreported statistics would be sent when a job terminates.

<font color=blue>
<pre>
  ELstatistics stats (cerr); 
</pre>
</font>

     <li> <b>ELcollected</b> 
	is constructed taking an instance of an <b>ELsender</b> class
	defined by the user to implement the mechanism by which data would
	be transmitted to a collecting process.  <a href="coll.html"> 
	Collective error logging </a> is explained elsewhere.
</ul>

   The usual framework will use one or more
   ELoutput sinks, an ELstatistics, and perhaps an ELsaveBuffer.

   To attach a destination, the frameworker must instantiate it, and 
   attach the destination to the ELadministrator.  Attaching the destination
   returns an <b>ELdestControl</b> object, which is a handle for controlling 
   the behavior of that destination.  If no destination is attached to the 
   ELadministrator then one is attached automatically to "cout" when the first
   error is logged.
<p> 
  Thus, instantiating a destination and attaching it to the logger leaves
  the framework with an ELdestControl to use to affect that destination.

<font color=blue>
<pre>
  ELadministrator logger = ELadministrator::instance();
  ELdestControl logfile;
  logfile = logger->attach(ELoutput ( "filename.log" ));
</pre>
</font>
   Later, the ELdestControl may be used to control the behavior of this 
   destination, as in

<font color=blue>
<pre>
  logfile.setLimit("*", 20);
</pre>
</font>

<a name="handleId">
  Sometimes it may be desirable to modify the behavior of a destination
  from some other part of the framework or user code, where the original
  <b>ELdestControl</b> may no longer be available.  To anticipate that, 
  the <b>attach()</b> method has a signature taking an extra arguement:
  a string identifying the <b>ELdestination</b>.

<font color=blue>
<pre>
  ELadministrator logger = ELadministrator::instance();
  ELdestControl logfile;
  logfile = logger->attach(ELoutput ( "filename.log"<font color=red>, "myIdString"</font> ) );
</pre>
</font>

  A description of how one recovers a handle to <b>logfile</b> ginve the 
  string <b>"myIdString"</b> appears in 
  <a href="further.html#handleRecovery">Further Options for the Frameworker</a>.

<p>

   For completeness, there is a way to wipe a destination off the list
   of those the logger will dispatch to:

<font color=blue>
<pre>
  logger->detach ( logfile );
</pre>
</font>

It is recommended that ELstatistics be attached after 
the ordinary destinations, so the statistics table can accurately
reflect whether any destination reflected to a given message.



<hr>
<a name="errlog">
<h3> How the Module (or Package) Sets Up errlog </h3>
</a>

<font size=-1>
<ul>
   (Although in these notes we use the CDF term "Module" for the base 
   class that a package of physicists' codes is associated with, in D0 the same
   concept is called a Package.)  
</ul>
</font>

   The class for each module should allow its methods to log errors by 
   containing a variable object of the type <b>ErrorLog</b>.  
This should be done 
   by giving the base class Module, which all modules classes derive from, 
   an instance of ErrorLog.  The name of this object should be known to the 
   various physicists coding parts of the module.  We assume that this variable
will be named
   "<b>errlog</b>."  
This should be placed in the protected section, not private, so 
that methods of the derived classes can make use of errlog.
<p>
The ErrorLog instance will contain a small amount of module-specific 
   information, but most work is actually done by the ELadministrator 
   set up by the 
   framework.  For instance, the ELadministrator will hold the list of 
   destinations for messages sent to the log.  Since there is inherently 
   only one instance of ELadministrator, the many instances of ErrorLog 
   will send to destinations in a coherent and unified way.
<p>
   After instantiating errlog, the Module class should provide a module name, 
   to use when methods of this class issue an error message to the log.  
   Thus in the Module base class, the lines setting up the ErrorLog will
   look something like:
<font color=blue>
<pre>
  class Module {
  public:
    virtual string getModuleName(); 
    Module(string name) {
      errlog.setModule(name);
    };
  // ...
  protected:
  //...
    Errorlog errlog;
  }
</pre>
</font>

   (An additional routine, setPackage(name), is identical to setModule(name).)
<p>
   If this scheme is used, 
   the classes derived from Module, which contain the
   physicists' code, need do nothing further to be able to issue messages to 
   <b>errlog</b>.

<p>
A simpler scheme would be to have a glogbal ErrorLog named <b>errlog</b>, and
then everybody could log through  that same errlog.  In that cse, however, 
all the messages would be assigned the same module name (unless users
were to explicitly call errlog.setModule() before logging a message).


<hr>
<a name="howcontext">
<h3> ELcontextSupplier: How the run and event numbers are indicated </h3>
</a>

   The run and event are printed in the text of every error message.  However,
   the framework does not have to call some setEvent() method 
   every time a new event 
   is started.  
In order to avoid overhead for every event (when errors might 
   be logged in only a tiny fraction of those events), this information is not 
   pre-supplied by the framework.
<p>
   Instead, when an error is being logged, the logger asks for the run and 
   event names at that point.  It asks by invoking the context() function
   of the <b>ELcontextSupplier</b> object set up for the logger.
<p>
   The frameworker should create a class derived from <b>ELcontextSupplier</b>
and 
pass an instance of that class to the constructor of the ELadministrator,
as shown above ("How the frameworker sets up for logging").  
<p>
   ELcontextSupplier defines the following simple interface:

<font color=blue>
<pre>
  class ELcontextSupplier {
  public:
    virtual ELstring context () = 0; 
    virtual ELstring summaryContext () = 0; 
    virtual ELstring fullContext () = 0; 
    void editErrorObj(ErrorObj & msg);
  };
</pre>
</font>

   As seen from this, the class derived from ELcontextSupplier <em>must</em>
   define the three virtual methods returning ELstring, though some may be 
   identical to others.

   Although destinations are free to call for and use whichever context string
   they wish, the intent of the three forms is as follows:
<ul><dl>
<dt>   context() <dd>
		is the form used by the typical output-to-a-log-file 
			destination, for example ELoutput.  Here the string
			ought not to be too long, to avoid clutter in the log;
			but not limitation or truncation is imposed per se.
			A typical string would be 
			<font color=brown>run= 1234 event= 12345</font>.

<dt>   summaryContext()<dd>
		is the form used by ELstatistics to get a string 
			suitable for insertion into a table.  This is 
			length-critical, and will be truncated at 16 characters
			in the statistics summary.  A typical string would be
			<font color=brown>1234/12345</font>.

<dt>   fullContext() <dd>
	is a form intended for use where extra info may be 
			useful and length is not a big consideration.  ELoutput
			can enable fullContext() instead of context() on a
			per-destination basis.  fullContext() would typically
			just return context(), but another example might be
			<font color=brown>
			run= 1234 event= 12345 reco version 3.2</font>.
</dl></ul>


   The editErrorObj() routine will be called when the message is started.
   It provides a hook to modify the module or subroutine information, the
   id, or any part of the message other than the actual text items (which 
   would not have been established yet).  This method is optional; the
   editErrorObj() method of the base ELcontextSupplierI class is an inline
   method doing nothing.
<p>
   The context supplier is spcified via the setContextSupplier() method of
   ELadministrator.  If this method is not invoked, no context information 
   will be associated with error messsages. 

<p>
<hr>
<a name="threshlim">
<h3>Basics of Thresholds and Limits </h3>
</a>
   Some nomenclature:  Thresholds and limits both apply to particular 
   destinations.  
	<ul>
	<li> When we say <b>limit</b>, we shall always mean some count 
   of messages of a particular description, beyond which some action will 
   cease to happen.  A limit can be specified by message id, or for multiple 
   id's in two ways:  A general wildcard, or all messages of some severity 
   level.  
	<br>
   When we say <b>threshold</b> we shall always mean some ELseverityLevel, 
	at or above which some action would happen.  
</ul>
   One can set a limit or a threshold for each individual destination.
   (using its ELdestControl).
   To do this, you use methods of the associated ELdestControd, which we
   will call "dest" for these examples.   The effects are as follows:

<dl>
<dt>   <font color=blue> dest.setThreshold (severity); </font> <dd> 
      Supress logging or acting on 
                                        messages below this severity, 
                                        for this destination.
<dt>   <font color=blue> 
   dest.setLimit     (id, n); <br> 
   dest.setLimit     (severity, n); <br>
   dest.setLimit     ("*", n); </font> <dd>
					For this destination, don't 
					log past <b>n</b> instances of any
					given exception id matching the
					specified type.
</dl>
   In case one has established two or more applicable limits, the limit used
   is the most specific applicable case: Specified ID before specific severity
   level, and both before wildcard "*".  
<p>
   As implied by the above chart, each ELdestination owns a threshold level
   (if no threshold is explicitly set, the threshold is ELzeroSeverity).
   Each ELdestination also owns a general limits table (indexed by severity
   level) and a limits table (indexed by message id).  Each limits table
   entry contains as data the limit and the count.
<p>
<a name="indexELstatisticsFiltering"> </a>
   ELstatistics is a particular destination.  That means 
   that filtering by severity is set up via setThreshold.  In the case of an
   ELstatistics destination, however, setLimit has no effect:  Once an error
   message id gets into that table, there is absolutely no cost to incrementing
   its count, so a limit would be useless.
<p>
  The <a href="SampleFramework.html"> Sample Framework </a> illustration 
  shows how limits and thresholds are set up.
<p>
   Although a limit conceptually may or may not have been set, and if no limit
   whatsoever applies, no messages will be throttled out, the threshold 
   severity level always has a value.  By default, in each individual 
   destination, this threshold starts as ELzeroSeverity.
<p>
<a name="indexBackoff"> </a>
   For convenience, the ELadministrator also has setThresholds() and setLimits()
   methods.  The meaning of those is to invoke the corresponding method for
   <em>every</em>
destination currently attached to the logger.  (That might change 
   some limits previously established.)  
<P>

   Finally, two features slightly soften the concept of throttling via a limit.
   The first is that a count is past its limit, action does not cease 
   completely:  If the applicable limit for a given error would be <em>L</em>,
   then if there is an excess <em>E = count-L</em>, instances with 
   <em>E/L = 2**N</em>  for any
   non-negative integer <em>N</em>, will be logged.  
   Thus if the limit for a specific message is 5, the loggger would contain 
   numbers 1, 2, 3, 4, 5, 10, 15, 25, 45, 85, 165, and so forth.
<p>
   The second concept applies when a large bunch of errors of some type 
   is followed by a long time span with no such errors.  At that point the count
   toward the limit may automatically be reset, so that a new cluster of these 
   errors can again be logged.  This is controled by 

<font color=blue>
<pre>
  dest.setTimespan ( id, seconds );
</pre>
</font>
where the id works the same way and uses the same wildcards as for limits.

<p>
<hr>
<a name="modulefilter">
<h3>Filtering by Module or Multiple Modules </h3>
</a>

You can set up a destination (<code>ELouput</code>, 
<code>ELcollected</code>, <code>ELerrorList</code> 
or <code>ELstatistics</code>) to react only to messages coming from one module:

<font color=blue>
<pre>
  dest.filterModule ( "Calorimetry" );
</pre>
</font>

The destination controlled by <code>dest</code> will now only react to 
error messages logged from a module whose name has been set to 
<code>setModule("Calorimetry")</code>.  (Note that the comparison is 
case-sensitive.)

<p>
Other filtering behaviors, that is, limits and thresholds, will still apply to
this destination, acting on those error messages which survive the module test.

<p>
Alternatively, you can set up a destination to <em>exclude</em>
all messages coming from one module:
<font color=blue>
<pre>
  dest2.excludeModule ( "MuonIdent" );
</pre>
</font>

The destination controlled by <code>dest2</code> will now ignore all
error messages logged from a module whose name has been set to 
<code>setModule("MuonIdent")</code>  (again the comparison is 
case-sensitive.)  
<p>

These routines are a special case of a more geneneral capability:
<p>
The model is that there is a <em>`respondToModule'</em> list and an 
<em>`ignoreModule'</em> list.  
At any given time, either the <em>`respondToModule'</em> list or the
<em>`ignoreModule'</em>`ignoreModule' list (or neither) may be active, 
but not both.
<p>
 Then there are two ways to call each of two methods to influence these:

<font color=blue>
<pre>
  dest.ignoreModule ("*");
</pre>
</font>
<ul>
        Clear <em>`respondToModule'</em> list, and filter out all messages, except
        those coming from any module that is later added to the
        <em>`respondToModule'</em> list.
</ul>

<font color=blue>
<pre>
  dest.respondToModule ("name");
</pre>
</font>
<ul>
 Add this module to the <em>`respondToModule'</em> list, and remove it (if
        present) from the <em>`ignoreModule'</em> list.
</ul>

<font color=blue>
<pre>
  dest.respondToModule ("*");
</pre>
</font>
<ul>
        Clear <em>`ignoreModule'</em> list, and respond to all messages, except
        those coming from any module that is later added to the
        <em>`ignoreModule'</em> list.
</ul>

<font color=blue>
<pre>
  dest.ignoreModule ("name");
</pre>
</font>
<ul>
 Add this module to the <em>`ignoreModule'</em> list, and remove it (if
        present) from the <em>`respondToModule'</em> list.
</ul>

The filter and exclude routines
are expressed in terms of ignoring and responding to modules:
<p>
<code>dest.filterModule("a")</code> has the same effect as 
<font color=blue>
<pre>
  dest.ignoreModule("*"); 
  dest.respondToModule("a"); 
</pre>
</font>

<code>dest.excludeModule("a")</code> has the same effect as 

<font color=blue>
<pre>
  dest.respondToModule("*"); 
  dest.ignoreModule("a"); 
</pre>
</font>

<p>
<hr>
<a name="discardThreshold">
<h3>Rapid Discarding Below a Severity </h3>
</a>

   The frameworker can short-ciruit the formatting,
   timestamping, and "shopping" the message to each destination that occurs
   when a low-severity error message is sent:

<font color=blue>
<pre>
  errlog.setDiscardThreshold (sev);
</pre>
</font>
<p>
  This threshold is sent for the particular instance of <b>ErrorLog</b>.  
  It might normally be set to the lowest threshold of any destination; 
  but in special circumstances one could specify that any message sent to this 
  <b>Errorlog</b> with severity less than some higher threshold is to be 
  discarded.
<p>
   The meaning is that any messages sent through the usual mechanism of
<pre>
   errlog ( severity, id ) << items << endmsg;
</pre>
which have severity less than sev, will be discarded with the absolute 
minimum possible work.  
The message will not be shopped for each destinations to react to,
and each operator<< will simply return, doing no work.  
The net effect is a speedup of null-message processing by a factor of about 30.
<p>
The discardThreshold works like other thresholds in that if a message
severity is greater or equal to the threshold, it can be reacted to.
The discardThreshold takes precedence over individual destinations'
thresholds.
<p>
An example of usage, and demonstration of the differnce in speed,
is in the file
<a href="../../Tests/testDiscard.cc">testDiscard.cc</a>.

<p>


<hr>
<a name="debugVerbosity">
<h3>
Establishing Debug Verbosity Levels </h3> 
</a>

The ErrorLogger package supports a separate syntax for issuing information
intended for debugging (see 
<a href="physicist.html#debug"> "Issuing debuggging information messages" </a>).
<p>
The idea is that this output can easily be disabled at an overall
level, set on a per-ErrorLog basis by the framework.
The fundamental notion is that of a debug "verbosity" level, which is simply
an integer.  
If a message is given a level which is higher than the cuttoff chosen by the
framework for that logger, then that message will be completely (and
efficiently) ignored.  

<font color=blue>
<pre>
  errlog.setDebugVerbosity(3);
</pre>        
</font color=blue>

The default, if no debug verbosity level is set for an ErrorLog,
is a level of 0:
All debug messages assigned any positive verbosity level will be ignored by
default.

<p>
The cuttoff on debugging verbosity level is controllable for each individual
ErrorLog.  This allows the framework to accomodate
cases where verbosity needs to be high for one module but 
not for others.

<p>
By default, every message issued through this debug message mechanism is
assigned a severity of <b>ELinfo</b> and a message id of <b>"DEBUG"</b>.
The framework can alter this for a given ErrorLog, for example:
<font color=blue>
<pre>
  errlog.setDebugMessages ( ELwarning, "differentID" );
</pre>        
</font color=blue>

<p>
The mechanism of debug verbosity levels acts very much like that of 
discard thresholds for the ErrorLog, in that:
<ul>
<li> If the debug verbosity is too low, the message is discarded 
     regardless of thresholds set for various destinations, and never
     even makes it to statistics.
<li> If the debug verbosity "cut" is passed, then individual output
     destinations may still reject a given message based on its severity
     not being high enough.  In particular, by default destinations which 
     don't react to <b>ELinfo</b> severity will not react to 
</ul>
One distinction is that since the level can be any integer, the granularity
availble is not restricted by the limited number of severity levels.

<p>
<hr>
<a name="abort">
<h3> Controlling abort and exit() behavior </h3>
</a>

   The higher severity levels are used by physicists to indicate that they
   consider this error so severe as to warrant terminating the job.  However, 
   ultimate control of this rests in the hands of the framework.  The control
   is associated with the logger (the ELadministrator) rather than any specific
   destination.
<font color=blue>
<pre>
  logger->setAbortThreshold (ELfatal);
</pre>
</font>
   By default, the abort threshold is <b>ELabort</b>.  
<p>
   If the physicist issues a log message with severity as at or above the
   abort threshold, 
   <font color = red> <em> upon completion of the log message </em> </font> 
   and dispatch of that to
   the various destinations, the logger will terminate the job by invoking
   abort().  This will cause a core file (potentially useful for debugging)
   to be produced.  No termination summary is given.
<p>
   A plausible philosophy is to set the abort threshold at 
  <b>ELhighestSeverity</b>, so
   that NO user message aborts the job.  In that case, we advise periodically
   checking for the presence of severe errors (see 
   <a href="further.html">"Checking on errors"</a>).
<p>
   The abort() routine causes a core dump, which normally will be useful
   to trace down the cause of the error.  However, in some cases the source
   of errors may be known, and production runs may be better off not consuming
   the disk space taken up by core files.  The framework has the option of
   causing errors of some severity levels to invoke exit (severityLevel) 
   rather than abort.  If exit() is invoked, a termination summary is given.
   Assuming the framework had established an atexit() 
   handler, this would be called as the job exits.
   The exit() call will not cause a core file to be produced.
<font color=blue>
<pre>
  logger->setExitThreshold (ELfatal);
</pre>
</font>
   By default, the exit threshold is <b>ELhighestSeverity</b>, that is, 
   unless an exit threshold is specificallyestablished, the automatic exit()
   behavior will not occur.  
<p>
The framework can provide flexibility, so that some errors will still cause
an abort() while others will cause an exit().  The rules used to decide whether
to abort or exit, when encountering an error message of severity <b>s</b>,
are as follows:
<ul>
<li>
  If <b>s</b> is of lower severity than both the abort and the exit thresholds,
  then of course neither form of termination occurs.
<li> 
  Among the thresholds which are less than or equal to <b>s</b>,
  the termination action chosen is the one with the <em>higher</em> threshold.
<li>
  It is suggested that the thresholds not be set to be identical; if they are,
  then the action chosen for sufficiently severe messages will be abort() and
  the choice of exit() will never be taken.
</ul>

<p>
A typical setup would be:
<font color=blue>
<pre>
  logger->setAboutThreshold (ELabort); // not really needed; this is default
  logger->setExitThreshold (ELfatal);
</pre>
</font>
With this setup, messages issued at <b>ELfatal</b> severity will 
exit(), while messages issued at <b>ELabort</b> severity abort() and core dump.
  
    

<p>
<hr>
<a name="checking">
<h3> Checking on errors</h3>
</a>

   Since severity levels above ELnext indicate advice that the flow of
   processing ought to be modified or ceased, it is advisable (in all but
   the most time-critical applications) that the framework check for the
   presence of such errors, between invoking modules or between events.  
   To make this inexpensive, a routine checkSeverity() is provided.  

<font color=blue>
<pre>
	ErrorSeverity highest = logger->checkSeverity();
	if ( highest >= ELnext ) { do whatever };
</pre>
</font>

   This routine provides the severity level of the highest error declared 
   since the last checkSeverity(), or ELzeroSeverity if none have been 
   declared since the last check.

<p>
<hr>
<a name="stats"> 
<h3> Obtaining error statistics summaries </h3>
<a/>

   Assuming the frameworker has attached an instance of the provided 
   <b>ELstatistics</b> destination to the logger, statistics summaries may be 
   obtained.  ELstatistics has no visible reaction to being sent an error 
   message, but places information into a table, which can be formatted and
   output.  For the purposes of the illustrations below, we will assume that
   the logger has attached an ELstatistics destination, with an ELdestControl
   called "<b>stats</b>."
<p>
   The summary of error statistics can be obtained as a string.  It can also
   be sent to a destination device (as a series of summary lines); ELoutput
   places these lines into its associated stream to output the summary.  
<p>
   The summary may be obtained in several ways:

<font color=blue>
<pre>
  stats->summary(dest); // Sends the summary to this destination.
  stats->summary(os);   // Sends the whole summary string as a char*, 
                        // to some arbitrary ostream os.
  stats->summary(s&);   // Sends the whole summary string to ELstring s. 
</pre>
</font>

   Each of the above forms also has an optional last argument, containing a 
   title to insert into the first line of the summary.

<font color=blue>
<pre>
  stats->summary(dest, "summary title");
  stats->summary(os,   "summary title");
  stats->summary(s&,   "summary title");
</pre>
</font>
   There is an additonal means of having the summary sent to an ostream:  If
   the constructor of ELstatistics is supplied an ostream argument, then when
   the job completes the destructor for that ELstatistics will check to see
   if any information has changed since the last summary request.  If so, one
   final summary will automatically be sent to that ostream.  (This is safe 
   assuming the user does not explicitly delete the ostream before the 
   statistics destination goes away.)
<p>
   To suppress the termination summary altogether:
<font color=blue>
<pre>
  stats.noTerminationSummary();
</pre>
</font>
<p>
   The format of the summary information is that of three parts: 
<ul>
   <li> The first part lists the errors which have occurred, 
	with their frequencies. 
   <li>
	The second part re-lists just the identification, 
	and supplies the contexts
   (usually run/event of the first two and last examples of 
   occurences of each error.
   <li>
   The third part lists the count of occurences of each severity level.
</ul>
<p>
   To illustrate how a summary would look:

<font color=brown>
<pre>

%ERLOG  ===============  SUMMARY  ===  summary title  ==========================

Process job123a
 type  message id         sev   module         subroutine        count    total
 ---- -------------------- - ----------------- ----------------  -----    -----
    1 Bank Error           E central tracker   refine_candidate     97       97
    2 Bank Error           E central tracker   prepare_sigma         5        5
    3 Bank Error           E muon tracker      prepare_sigma         5        5
    4 Energy overflow      S CALhadron         sanityChecks          1        1
    5 Too many tracks      w track matching    start_seeds          11*      11
    6 Too many stray trax  w CTKtrack          countTracks          32       32
    7 Too many stray trax  E CTKtrack          checkTracks           4        4

* Some occurences off this message were suppressed in all logs, due to limits.

 type   message id   Examples:  run/evt         run/evt          run/evt
 ---- -------------------       -------         -------          -------
    1 Bank Error             14231/54101      14231/54103      14239/59350     
    2 Bank Error             14231/54215      14232/55506      14238/58190     
    3 Bank Error             14231/54200      14232/55606      14239/59195     
    4 Energy overflow        14235/60305    
    5 Too many tracks        14231/54101      14231/54506      14238/59190     
    6 Too many stray trax    14231/54164      14231/54171      14239/59195     
    7 Too many stray trax    14231/54100      14231/54191      14239/60012

 Severity	Number of occurences	  Total
 --------	--------------------	---------
    ..			275984		  512902
  SUCCESS	         21000             42000
  INFO			  2100		    4200
  WARNING		   325		     604
  ERROR			     4		       6
  ERROR!		     1		       1
  SEVERE		     1		       1
</pre>
</font>
<p>
<hr>

<a name="clear">
<h3> Clearing statistics and/or limits </h3>
</a>

   The method to clear the counts in the statistics being kept in 
   the destination whose ELdestControl is "stats" is
<font color=blue>
<pre>
  stats.clearSummary();
</pre>
</font>

   This clears both the individual statistics (kept by message ID) and the
   counts for the various severity levels.  It would normally be used after 
   having invoked stats.summary() in some form to send the information 
   somewhere.
<p>
   clearSummary() does not zero the aggregate counts for individual error IDs
   or for severity levels.  It also does not affect any limits set, or wipe
   the knowledge of the message IDs from the statistics tables.  (Thus there
   would remain a bunch of errors with counts of zero; when statistics are
   output these do not appear.)
<p>
   There is a more sweeping method:

<font color=blue>
<pre>
  stats.wipe();
</pre>
</font>

   This clears everything -- counts and aggregate counts for individual ID's 
   and for severity levels.  The statistics is wiped clean, which may be 
   relevant if memory management issues have imposed a limit on the number of 
   message ID entries in the statistics table.
<p>
   The same routine also wipes out any information in the limits table.  This
   includes values which have been supplied by setLimit() (or setTimespan()),
   and counts of the individual instances of each message ID.  For the 
   ELstatistics destination this is moot (since limits do not apply) but for 
   ELoutput or ELsaveBuffer this may be useful when a maximum number of 
   message ID entries in the limits table has been imposed.
<font color=blue>
<pre>
  dest.wipe();
  logger.wipe();     // Applies wipe() to all attached destinations
</pre>
</font>

   This clears everything -- counts and aggregate counts for severity levels 
   and for individual ID's, as well as any limits established.  (This includes
   the limits for "*" all messages.)  The table is wiped clean, which may be 
   relevant if memory management issues imposes a limit on the number of 
   message ID entries in the statistics table.
<p>
   Finally, there is a way to zero the counts going toward the limits all
   IDs in a destination.  This does not affact ELstatistics (which does not
   use limits) and will not compactify the limits table.
   It also does not affect aggregate counts.
<font color=blue>
<pre>
  dest.zero();
</pre>
</font>


<p><center>
<img src="http://www.fnal.gov/docs/working-groups/fpcltf/icons/bar.gif"></center>

<p><center>
<a href="0ErrorLogger.html">
ErrorLogger Package Page </a> 
<p>
</center>
      <hr>
      <address><a href="mailto:mf@fnal.gov">Mark Fischler</a></address>
<!-- hhmts start -->
Last modified: Thu Mar 15 2001
<!-- hhmts end -->
</body>
