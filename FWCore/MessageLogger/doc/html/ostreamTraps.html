<title>
Traps to Avoid When Changing ostreams for an ELoutput
</title>
<body bgcolor=FFFFFFFF>
<center>
<h1>
The ZOOM ErrorLogger Package:
<p>
</h1>
<h2>
<font color=red>
Trap to Avoid When Changing ostreams for an ELoutput
</font>
</h2>
</center>
<p>
If you change the ostream associated with an <b>ELoutput</b> 
destination, you need to be careful to avoid this ways of shooting
yourself in the foot:
<p>
<h3>
Leaving two active handles to the same file 
</h3>
<ul>
  Say your code looks as follows:
  <font color=blue>
  <pre>
  ELadministrator logger = ELadministrator::instance();
  std::ostream os1("thisFile");
  ELoutput output (os1);
  logfile = logger->attach(output);
  logfile.changeFile("thisFile");
  </pre>
  </font>
  What you have done is to create two std::ostreams refering to the same
  actual file, exactly as if you had done
  <pre>
  std::ostream os1("thisFile");
  std::ostream os2("thisFile");
  </pre>
  <b>os1</b> has not been deleted and remains completely accessible.
  If you stream data to <b>os1</b> and also send messages to <b>logfile</b>
  there will be a clash, and unpredictable behavior.
</ul>



If you use the same signature for changing the ostream as was used for
constructing the ELoutput (either both by suppling a std::ostream or 
both by supplying a string to use as a file name) then you cannot get 
into trouble.  In particular, changing from one 
file to the identical file will work fine:  The file will be closed, then
re-opened for appending.
