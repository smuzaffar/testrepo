<title>
Collective Error Logging 
</title>
<body bgcolor=FFFFFFFF>
<center>
<h1>ZOOM <img src="http://www.fnal.gov/docs/working-groups/fpcltf/icons/
particle_coll_bar_463_grey.gif" align="center"> ZOOM</h1>
</center>
<p>
<center>
<h1>
The ZOOM ErrorLogger Package:
<p>
<font color=red>
Collective Error Logging 
</font>
</h1>
</center>
<p>

<h2> The General Idea </h2>

<h3> The Need </h3>

The experiment has several (or many) processes, probably on multiple CPU's, 
running jobs as part of a unified overall production.  These jobs will on 
occasion issue error messages using the ZOOM <b> ErrorLogger </b> package.
(We will refer to these jobs as the "clients.")
<p>
However, instead of many distinct Error Log files, the experiment would like
all these error messages to come out in a unified way from one collecting
process which we will refer to as the "server."  

<h3> Meeting this Need </h3>

The package now provides a new ELdestination named 
<b><code>ELcollected</code></b>.  
ELcollected has a user interface just like the usual ELoutput destination, 
and in fact is derived from ELoutput, so the changeover to collective
logging for a client program already doing logging should be very easy.
<p>
The package also has a way to invoke an ErrorLogger supplying a buffer of
message data.  This call, used on the server side, lets you take the message
that has come in and get it to the server's error log as if it were an 
ordinary locally-issued error message (but with the remote process and
context indicated).

<h3> The Transport Mechanism </h3>

Each experiment (and possibly each level of trigger and/or reconstruction 
within an experiment) is likely to have its own prefered means of moving data
between the clients and the server.  The ErrorLogger package does not try to 
dictate how this is done.  Instead, it lets the experiment provide:
<ul>
<li>
A method (on the clients) that takes a byte count and buffer, 
and transmits it to the desired server.  
<li> 
Code on the server that catches these transmissions, and each time one 
arrives, passes the byte count and data to the errorlog object.
</ul>

<a name="indexSendingEnd"> </a>
<h2> Setting Up at the Sending End </h2>

<h3> Establishing the Destination </h3>

In the place where your framework had been setting up an <code>ELoutput</code>
destination, instead (or in addition) set up an <code>ELcollected</code>.
This class is derived from <code>ELoutput</code>, and you can control its
behavior in the same way.  But the constructor for an ELdestination takes
an <code>ELsender</code> object (see below) that defines how the transport
mechaninsm is done.
<ul>
<pre>
MySender transmitter ( );  <font color=blue>
ELcollected collectedD  ( transmitter );
ELdestControl collected ( logger->attach(collectedD) );
collected.setThreshold  ( ELwarning );  // and other controlling statements </font>
</pre>
</ul>
Note that you can, if you wish, establish multiple <code>ELcollected</code>
destinations, with different transport mechanisms, thresholds, and so forth.

<h3> Defining the Transport Mechanism </h3>

To define the transport mechanism used by the experiment, 
you will need to declare a class derived from <code>ELsender</code>.
The header of this class is quite simple and should copy this boilerplate:
<ul>
<pre>
<font color=blue>class MySender : public ELsender { </font>
public:
  MySender ( );  // or a signature taking some arguments 
  <font color=blue>void send (int nbytes, const char * data);</font>
  ZM_COVARIANT_TYPE(ELsender *, MySender *)  clone() const;
protected:
  // Any data you need to know to do your transport mechanism.
};
</pre>
</ul>

The implementation of the clone method also follows
a simple boilerplate:
<ul>
<pre>
ZM_COVARIANT_TYPE(ELsender *, MySender *) MySender::clone() const { 
  return  new MySender ( *this );
}
</pre>
</ul>

The constructor can be completely trivial, or it might take arguments
to specify something about the desired transport.  For example, if there
are several possible points of collection in a VME-based system, you can 
have the constructor take a VME bus address or whatever.  
<p>
We have a toy
example in <a href="../../Tests/BasicColl.cc">BasicColl.cc</a> which mocks up
a transport mechanism by writing to a file which will later be read by a 
server job; there MySender has a data member specifying the file, and the
constructor looks like
<ul>
<pre>
MySender::MySender ( ofstream & fs ) : file (fs) {}
</pre>
</ul>
<p>
The key method is <code>send(nbytes, data)</code>; this has to take the
<code>nbytes</code> starting at pointer <code>data</code> and transmit it
to the desired server.

<h3>Logging Error Messages</h3>

The rest of the code, which might log error messages in various places
using an ErrorLog object, 
<font color = red> <em> remains unchanged. </em> </font>

<h2> Setting Up at the Collecting (Server) End </h2>

Fundamentally, the server has to set up its own error log, with whatever
destinations it wants.  Then when each message arrives via the transport
mechanism, it must pass the bytecount and data to the <code>errlog</code>
object.
<p>
A toy
example in <a href="../../Tests/BasicRecv.cc">BasicRecv.cc</a> acts as the
server end of our mocks transport mechanism used by 
in <a href="../../Tests/BasicColl.cc">BasicColl.cc</a>, reading a message
at a time from the file created and responding to it as if the message came
from a genuine asynchronous transport mechanism.

<a name="indexServer"> </a>
<h3> Setting up the Server's Error Log </h3>

The Server process is like any job in its use of the ErrorLogger package.
That is, it calls <code>ELadministrator::instance()</code> to get an
<code>ELadministrator</code>, attaches one or more <code>ELdestination</code>s
to that, and instantiates an <code>ErrorLog</code> which we conventionally
call <code>errlog</code>.
<p>
But here <code>errlog</code> is intended to field error messages stemming from 
the remote client processes, rather than from problems arising in the server
itself.
<ul>
<pre>
ELadministrator * logger = ELadministrator::instance();
ELoutput          logfileD( "logFIleName.errlog" );       
ELdestControl     logfile ( logger->attach(logfileD) ); 
<font color=blue>ErrorLog errlog ("*");</font>
</pre>
</ul>
<p>
Notice that we assigned a very short pkgName name to 
<code>errlog</code> in this example.
That is because this name will be 
prepended to the module name of each message coming from a client.
For readability (and especially in statistics keeping, where only the first 
16 characters of the module name are keyed upon) it is desirable to keep 
this name short.
<p>
The server process may well have duties beyond active as a central collection 
point for error messages.  If the server process itself may need to 
issue error messages, we recommend using one or more other 
<code>ErrorLog</code>s,
each of which can have an appropriate package name.
<ul>
<pre>
ErrorLog servererrlog ("From Server");
</pre>
</ul>
 
<h3> Fielding Messages </h3>

The key activities in fielding a message sent from the client process are
tied into the transport mechanism, as discussed below.  
Once the process is aware that a message has been received, and has the
<code>nbytes</code> of the message located at <code>*data</code>, the
server must do:

<ul>
<pre>
<font color=blue>errlog (nbytes,data) << endmsg;</font>
</pre>
</ul>

This looks like issuing any error message, but notice the arguments of
<code>errlog</code> now pertain to the message, 
rather than a severity and an id.
This special form of issuing an error message gets the following information
which was captured on the client when the ELcollected destination got the
error, rather than using local information:
<ul>
<li> The process name
<li> The module name
<li> The error severity level
<li> The error id string
<li> The run/event context 
<li> The subroutine name
<li> Each item which had been streamed to the error message on the client
</ul>
Thus the output to any destination on the server will look like the output
of the issued error message would have on the client.
<p>
The following example code hypothetically detects the presence of a 
message by polling, assuming that a function <code>getAmessage</code>
creates a buffer and places the message data in it, or returns false
if no new message is present.
<ul>
<pre>
while (1) {
  if (getAmessage(n, data)) {
    errlog (n,data) << endmsg;
    delete[] data;
  }
}
</pre>
</ul>
In realistic cases it may be more likely that some asynchronous mechanism 
is used instead.
<p>
Two small wrinkles in the product as currently implemented:
<ul> 
<li>
The time stamp will be the time when the <em>server</em> fields the
message and invokes its <code>errlog</code>, rather than the time the
message was issued on the client.
<li>
In the statistics kept by an <code>ELstatistics</code> destination on the 
server, similar messages from two distinct processes are not lumped together,
since the process name is considered part of the message id for that purpose.
</ul>

<h3> Receiving a Message - The Server Side of the Transport Mechanism </h3>

Of course, the transport mechanism is up to the experiment.  
However, it needs to have the following properties:
<ul>
<li> When a message is sent, it arrives - or is some how set out - 
as a single contiguous buffer of data and appropriate byte count.  
(The typical error message contains about 300 bytes or fewer of information.)
<li> When an incoming message has been received, somehow the code 
in the server process which will call 
<code>errorlog(nbytes, data)</code> must be invoked.  
Detection of the presence of a message 
is part of the transport mechanism.  For example, if MPI were used, you would
want to post a receive handler which copies puts the data into a local 
(stack) buffer, invokes the code that calls 
<code>errorlog(nbytes, data)</code>, and finally
posts another receive-with-handler.
<li> Verification of correctness of transmission is the responsibility of the 
transport mechanism.  The ErrorLogger package only does a rudimentary 
consistency check based on the number of bytes sent and a terminating double 
zero.
</ul>


<p><center>
<img src="http://www.fnal.gov/docs/working-groups/fpcltf/icons/bar.gif"></center>

<p><center>
<a href="0ErrorLogger.html"> Main ErrorLogger Package Page </a>
<p>
<a href="http://www.fnal.gov/docs/working-groups/fpcltf/fpcltf.html">
ZOOM Home Page </a> -

<a href="http://www.fnal.gov/faw/">Fermilab at Work</a> -

<a href="http://www.fnal.gov/">Fermilab Home</a>
</center>

<p>
      <hr>
      <address><a href="mailto:mf@fnal.gov">Mark Fischler</a></address>
<!-- hhmts start -->
Last modified: August 6, 1999
<!-- hhmts end -->
</body>
