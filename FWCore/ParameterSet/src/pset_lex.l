/*
 * $Id: pset_lex.l,v 1.4 2005/11/01 22:31:51 paterno Exp $
 * Author: Us
 * Date: 4/28/05
 * History:
 *
 */


%{
#include <cstdio>
#include <cstring>
#include <string>

#include "FWCore/ParameterSet/interface/Nodes.h"
#include "FWCore/ParameterSet/src/pset_parse.h"
#include "FWCore/Utilities/interface/EDMException.h"

  using namespace edm::pset;

  namespace edm { namespace pset { extern int lines; } }
  char* stringDup(const char*);
  char* stringDupQuoted(const char* s,char quotetype);

  /* 
     YY_BREAK is #defined to nothing, to silence a C++ from
     complaining about unreachable code
  */

#define YY_BREAK
#define yylval pset_lval

  /* the SQ.DQ things are start states, or context dependent sections */
  /* DQ is used to identify a double-quoted string                    */
  /* SQ is used to identify a single-quoted string                    */

%}

letterstart	[a-zA-Z]+[a-zA-Z0-9\-_\.]*
alphanumeric	[^\'\"\{\}\(\)\&=\n\t\r ,;:`]+
comment	#.*[\n]?
comment2 "//".*[\n]?

%x DQ
%x SQ

%%

"bool"		{ yylval.str=stringDup("bool"); return TYPE_tok; }
"int32"		{ yylval.str=stringDup("int32"); return TYPE_tok; }
"vint32"	{ yylval.str=stringDup("vint32"); return VTYPE_tok; }
"uint32"	{ yylval.str=stringDup("uint32"); return TYPE_tok; } 
"vuint32"	{ yylval.str=stringDup("vuint32"); return VTYPE_tok; } 
"string"	{ return STRING_tok; }
"vstring"	{ return VSTRING_tok; }
"double"	{ yylval.str=stringDup("double"); return TYPE_tok; }
"vdouble"	{ yylval.str=stringDup("vdouble"); return VTYPE_tok; }
"PSet"          { return PSET_tok; }
"VPSet"         { return VPSET_tok; }
"untracked"     { return UNTRACKED_tok; }
"FileInPath"    { return FILEINPATH_tok; }

"process"       { return PROCESS_tok; }
"source"        { return SOURCE_tok; }
"secsource"     { return SECSOURCE_tok; }
"es_source"     { return ES_SOURCE_tok; }
"path"          { return PATH_tok; }
"sequence"      { return SEQUENCE_tok; }
"block"         { return BLOCK_tok; }
"endpath"       { return ENDPATH_tok; }
"using"         { return USING_tok; }
"module"        { return MODULE_tok; }
"service"       { return SERVICE_tok; }
"es_module"     { return ES_MODULE_tok; }
"mixer"         { return MIXER_tok; }
"mixer_path"    { return MIXERPATH_tok; }

\&              { return AND_tok; }
\(		{ return GROUP_START_tok; }
\)		{ return GROUP_END_tok; }

{letterstart}	{ yylval.str = stringDup(yytext); return LETTERSTART_tok; }
{alphanumeric}	{ yylval.str = stringDup(yytext); return VALUE_tok; }
{comment}	{ ++lines; break ; }
{comment2}	{ ++lines; break ; }

\"\"		{ yylval.str = stringDupQuoted("",'"'); return DQWORD_tok; }
\'\'		{ yylval.str = stringDupQuoted("",'\''); return SQWORD_tok; }
\"		{ BEGIN DQ; break;}
\'		{ BEGIN SQ; break;}
=		{ return EQUAL_tok; }
,               { return COMMA_tok; }
\{		{ return SCOPE_START_tok; }
\}		{ return SCOPE_END_tok; }
\n		{ ++lines; break; }
\t              { break ; }
[ ]+		{ break ; }

<DQ>((\\\")*[^\"\n]*(\\\")*)+ { yylval.str = stringDupQuoted(yytext,'"'); return DQWORD_tok; }
<DQ>\"		{ BEGIN 0; break; }
<DQ>\n		{ ++lines; BEGIN 0; break; }

<SQ>((\\\')*[^\']*(\\\')*)+ { yylval.str = stringDupQuoted(yytext,'\''); return SQWORD_tok; }
<SQ>\'		{ BEGIN 0; break; }



%%

/* 
   The following was removed from the patterns above, 
   because it allowed some extraneous goo in files
   that should have been rejected
*/
#if 0
.		{ break ; }
#endif

int yywrap() { return 1; }


char* stringDup(const char* s)
{
  char* buffer = (char*) malloc(strlen(s)+1);
  strcpy(buffer, s);
  return buffer;
}

char* stringDupQuoted(const char* s,char quotetype)
{
  int len = strlen(s);
  char* buffer = (char*) malloc(len+1+2);
  strcpy(buffer+1, s);
  buffer[0]=quotetype;
  buffer[len+1]=quotetype;
  buffer[len+2]='\0';
  return buffer;
}

#if 0
static char* copy_clean(char* buf, char type)
{
  int leave=0,j=0,i,len=strlen(buf);
  char* x = (char*)malloc(len+2);
  x[0]=type;
  /* 
     should return a copy of buf with backslashes cleared out
     be careful about "\\", be sure to leave one of them 
  */
  for(i=0;i<len;i++)
    {
      if(leave || buf[i]!='\\')
	{
	  x[j+1]=buf[i];
	  ++j;
	  leave=0;
	}
      else
	{
	  if(buf[i+1]=='\\') leave=1;
	}
    }
  x[j+1]='\0';
  return x;
}
#endif


#include "FWCore/ParameterSet/interface/parse.h"
#include "boost/shared_ptr.hpp"

//  NOTE: the using declaration is before the include because the
//  header is autogenerated and I am not sure the autogenerator will
//  accept namespaces

using namespace edm::pset;
#include "FWCore/ParameterSet/src/pset_parse.h"

extern void pset_parse (void);

namespace edm {
   namespace pset {

     extern NodePtrList* global_gunk;

     // This is the function that actually creates the tree of nodes.
     // This function will either return a ParseResults object that
     // contains the parse results in "tree form", or will throw an
     // exception.

     ParseResults parse(char const* spec)
     {
       // Make sure state is clear.
       if (global_gunk)
	 throw edm::Exception(errors::Configuration, "BadParserState")
	   << "The configuration parser's global data is corrupt\n";

       // Make the tokenizer read from the character buffer
       // rather than a FILE*.

       YY_BUFFER_STATE buf = yy_scan_string(spec);
       yy_switch_to_buffer(buf);
       lines=1;

       // Do the parsing; this sets global_gunk. Immediately grab
       // ownership of the created structure.
       pset_parse();
       ParseResults ps(global_gunk);

       yy_delete_buffer(buf);

       // Can global_gunk be zero? I don't think so, but just to be
       // sure...
       if (!global_gunk)
	 throw edm::Exception(errors::Configuration, "BadParserState")
	   << "The configuration parser failed to set its global data\n";


       // ParseResults ps(global_gunk);
       // Don't delete global_gunk! The ParseResults object has taken
       // ownership.
       global_gunk=0;
       return ps;
     }
   }
}
