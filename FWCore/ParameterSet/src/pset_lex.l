
%{
#include "FWCore/ParameterSet/interface/Nodes.h"
using namespace edm::pset;

#include <cstdio>
#include <cstring>
#include <string>
#include "FWCore/ParameterSet/src/pset_parse.h"


  /*
    #include "InputString.h"

    #undef YY_INPUT
    #define YY_INPUT(b,r,ms) (r=input_data(b,ms))

    extern InputString input_data;
  */  

  // static int lines=1; // defined in yacc file
  // static char* copy_clean(char*,char); // not used
  namespace edm { namespace pset { extern int lines; } }
  char* stringDup(const char*);
  char* stringDupQuoted(const char* s,char quotetype);
/*
 * $Id: pset_lex.l,v 1.1 2005/05/29 02:29:55 wmtan Exp $
 * Author: Us
 * Date: 4/28/05
 * History:
 *
 */

/* 
   YY_BREAK is #defined to nothing, to silence a C++ from complaining
   about unreachable code
 */

#define YY_BREAK
#define yylval pset_lval

  /* the SQ.DQ things are start states, or context dependent sections */

%}

letterstart	[a-zA-Z]+[a-zA-Z0-9\-_\.]*
alphanumeric	[^\'\"\{\}\(\)\&=\n\t\r ,;:`]+
comment	#.*[\n]?
comment2 "//".*[\n]?

%x DQ
%x SQ

%%

"bool"		{ yylval.str=stringDup("bool"); return TYPE_tok; }
"int32"		{ yylval.str=stringDup("int32"); return TYPE_tok; }
"vint32"	{ yylval.str=stringDup("vint32"); return VTYPE_tok; }
"uint32"	{ yylval.str=stringDup("uint32"); return TYPE_tok; } 
"vuint32"	{ yylval.str=stringDup("vuint32"); return VTYPE_tok; } 
"string"	{ return STRING_tok; }
"vstring"	{ return VSTRING_tok; }
"double"	{ yylval.str=stringDup("double"); return TYPE_tok; }
"vdouble"	{ yylval.str=stringDup("vdouble"); return VTYPE_tok; }
"PSet"          { return PSET_tok; }
"VPSet"         { return VPSET_tok; }
"untracked"     { return UNTRACKED_tok; }

"process"       { return PROCESS_tok; }
"source"        { return SOURCE_tok; }
"secsource"     { return SECSOURCE_tok; }
"es_source"     { return ES_SOURCE_tok; }
"path"          { return PATH_tok; }
"sequence"      { return SEQUENCE_tok; }
"block"         { return BLOCK_tok; }
"endpath"       { return ENDPATH_tok; }
"using"         { return USING_tok; }
"module"        { return MODULE_tok; }
"es_module"     { return ES_MODULE_tok; }
"mixer"         { return MIXER_tok; }
"mixer_path"    { return MIXERPATH_tok; }

\&              { return AND_tok; }
\(		{ return GROUP_START_tok; }
\)		{ return GROUP_END_tok; }

{letterstart}	{ yylval.str = stringDup(yytext); return LETTERSTART_tok; }
{alphanumeric}	{ yylval.str = stringDup(yytext); return VALUE_tok; }
{comment}	{ ++lines; break ; }
{comment2}	{ ++lines; break ; }

\"\"		{ yylval.str = stringDupQuoted("",'"'); return DQWORD_tok; }
\'\'		{ yylval.str = stringDupQuoted("",'\''); return SQWORD_tok; }
\"		{ BEGIN DQ; break;}
\'		{ BEGIN SQ; break;}
=		{ return EQUAL_tok; }
,               { return COMMA_tok; }
\{		{ return SCOPE_START_tok; }
\}		{ return SCOPE_END_tok; }
\n		{ ++lines; break; }
\t              { break ; }
[ ]+		{ break ; }

<DQ>((\\\")*[^\"\n]*(\\\")*)+ { yylval.str = stringDupQuoted(yytext,'"'); return DQWORD_tok; }
<DQ>\"		{ BEGIN 0; break; }
<DQ>\n		{ ++lines; BEGIN 0; break; }

<SQ>((\\\')*[^\']*(\\\')*)+ { yylval.str = stringDupQuoted(yytext,'\''); return SQWORD_tok; }
<SQ>\'		{ BEGIN 0; break; }



%%

/* 
   The following was removed from the patterns above, 
   because it allowed some extraneous goo in files
   that should have been rejected
*/
#if 0
.		{ break ; }
#endif

int yywrap() { return 1; }


char* stringDup(const char* s)
{
  char* buffer = (char*) malloc(strlen(s)+1);
  strcpy(buffer, s);
  return buffer;
}

char* stringDupQuoted(const char* s,char quotetype)
{
  int len = strlen(s);
  char* buffer = (char*) malloc(len+1+2);
  strcpy(buffer+1, s);
  buffer[0]=quotetype;
  buffer[len+1]=quotetype;
  buffer[len+2]='\0';
  return buffer;
}

#if 0
static char* copy_clean(char* buf, char type)
{
  int leave=0,j=0,i,len=strlen(buf);
  char* x = (char*)malloc(len+2);
  x[0]=type;
  /* 
     should return a copy of buf with backslashes cleared out
     be careful about "\\", be sure to leave one of them 
  */
  for(i=0;i<len;i++)
    {
      if(leave || buf[i]!='\\')
	{
	  x[j+1]=buf[i];
	  ++j;
	  leave=0;
	}
      else
	{
	  if(buf[i+1]=='\\') leave=1;
	}
    }
  x[j+1]='\0';
  return x;
}
#endif


#include "FWCore/ParameterSet/interface/parse.h"
#include "boost/shared_ptr.hpp"

//NOTE: the using declaration is before the include because the header
//  is autogenerated and I am not sure the autogenerator will accept
//  namespaces
using namespace edm::pset;
#include "FWCore/ParameterSet/src/pset_parse.h"

extern void pset_parse (void);

namespace edm {
   namespace pset {
typedef boost::shared_ptr<NodePtrList> ParseResults;
extern NodePtrList* global_gunk;


ParseResults parse(char const* spec)
{
  YY_BUFFER_STATE buf = yy_scan_string(spec);
  yy_switch_to_buffer(buf);

  lines=1;
  pset_parse();
  yy_delete_buffer(buf);

  ParseResults ps(global_gunk);

//   if(global_gunk==0) return ParseResults();


//   ParseResults ps(global_gunk);
  global_gunk=0;
  return ps;
}
   }
}
