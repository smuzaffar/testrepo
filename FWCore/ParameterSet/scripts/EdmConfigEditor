#!/usr/bin/env python 
import cmd
import readline
import os
import sys
import glob
import re
if "CMSSW_BASE" in os.environ.keys():
    sys.path.append(os.environ["CMSSW_BASE"]+"/src/FWCore/ParameterSet/test")
if "CMSSW_RELEASE_BASE" in os.environ.keys():
    sys.path.append(os.environ["CMSSW_RELEASE_BASE"]+"/src/FWCore/ParameterSet/test")

import cmsconfig

class BadLabelException:
    def __init__(self,label):
        self.label = label
        return

class CmsBuilder(cmd.Cmd):

    def __init__(self,fileName):
        cmd.Cmd.__init__(self)
        readline.set_completer_delims(readline.get_completer_delims()+'.')
        self.prompt = "[no file]>"
        self.cfg = None
        self._esModuleLabels = dict()
        self._esSourceLabels = dict()
        self.addedCommands = list()
        r = re.compile('do_*')
        self._builtInCommandNames = [x[3:] for x in CmsBuilder.__dict__.keys() if r.match(x)]
        self._builtInCommandNames.sort()
#        print self._builtInCommandNames
        if 0 != len(fileName):
            self.do__read(fileName)
        
    def do_help(self,line):
        """Description: Show general help information
        Commands:
        help            show all available commands
        help <command>  show specific info about <command>"""
        if 0 != len(line):
            cmd.Cmd.do_help(self,line)
        else:
            print "Standard commands: "
            self.columnize(self._builtInCommandNames)
            print "\nConfiguration file commands: "
            r = re.compile('do_*')
            extraCommands = self.addedCommands
            extraCommands.sort()
            self.columnize(extraCommands)
   
    def do_process(self,line):
        """Description: Show the configuration for the process
        Commands:
        process    print summary of the configuration process"""
        if 0 == len(line):
            if(self.cfg):
                self.__print_process_summary()
            else:
                print "no configuration loaded"

    def __print_modules(self,line):
        """List module labels in the configuration"""
        if(self.cfg):
            names = self.cfg.moduleNames()
            names.sort()
            self.columnize(names)
    def do_module(self,line):
        """Description: Show information about modules
        Commands:
        module         list the labels for all modules
        module <label> print the configuration of the module"""
        if 0 == len(line):
            self.__print_modules(line)
            return
        if(self.cfg):
            try:
                self.__print_module(line)
            except BadLabelException,e:
                print "no module named '"+e.label+"'"

    def complete_module(self,text,line,begidx,endidx):
        #if the separator is not a space then no match
        # note: 6 is the length of the string 'module'
        if line[6] != ' ':
            return []
        r = re.compile(text+'.*')
        return [x for x in self.cfg.moduleNames() if r.match(x) ]

    def __print_es_modules(self,line):
        """List es_module labels in the configuration"""
        if(self.cfg):
            names = self._esModuleLabels.keys()
            names.sort()
            self.columnize(names)
 
    def do_es_module(self,line):
        """Description: Show information about es_modules
        Commands:
        es_module         list the labels for all es_modules
        es_module <label> print the configuration of the es_module"""
        if 0 == len(line):
            self.__print_es_modules(line)
            return
        if(self.cfg):
            try:
                self.__print_es_module(line) 
            except BadLabelException,e:
                print "no es_module named '"+e.label+"'"

    def complete_es_module(self,text,line,begidx,endidx):
        #if the separator is not a space then no match
        # note: 6 is the length of the string 'es_module'
        if line[9] != ' ':
            return []
        r = re.compile(text+'.*')
        return [x for x in self._esModuleLabels.keys() if r.match(x) ]

    def __print_es_module(self,label,line=''):
        if 0 == len(line):
            print "module: "+self.__find_es_module(label)['@classname'][2]
            self.__print_pset(self.__find_es_module(label),"  ")
        else:
            self.__print_pset_param(label,line,self.__find_es_module(label))

    def __find_es_module(self,label):
        try:
            internalLabel = self._esModuleLabels[label]
        except KeyError:
            raise BadLabelException(label)
        return self.cfg.esModule(self._esModuleLabels[label])

    def __print_es_sources(self,line):
        """List es_module labels in the configuration"""
        if(self.cfg):
            names = self._esSourceLabels.keys()
            names.sort()
            self.columnize(names)
 
    def do_es_source(self,line):
        """Description: Show information about es_sources
        Commands:
        es_source         list the labels for all es_sources
        es_sourcee <label> print the configuration of the es_source"""
        if 0 == len(line):
            self.__print_es_sources(line)
            return
        if(self.cfg):
            try:
                self.__print_es_source(line)
            except BadLabelException, e:
                print "no es_source named '"+e.label+"'"

    def complete_es_source(self,text,line,begidx,endidx):
        #if the separator is not a space then no match
        # note: 9 is the length of the string 'es_source'
        if line[9] != ' ':
            return []
        r = re.compile(text+'.*')
        return [x for x in self._esSourceLabels.keys() if r.match(x) ]

    def __print_es_source(self,label,line=''):
        if 0 == len(line):
            print "es_source: "+self.__find_es_source(label)['@classname'][2]
            self.__print_pset(self.__find_es_source(label),"  ")
        else:
            self.__print_pset_param(label,line,self.__find_es_source(label))

    def __find_es_source(self,label):
        try:
            internalLabel=self._esSourceLabels[label]
        except KeyError:
            raise BadLabelException(label)
        return self.cfg.esSource(internalLabel)

    def do_source(self,line):
        """Description: Show the configuration of the source
        Commands:
        source     print the configuration of the source"""
        if 0 == len(line):
            self.__print_source()

    def __parse_pycfg(self,txt):
        self.cfg = cmsconfig.cmsconfig(txt)
        self.__remove_labels()
        for label in self.cfg.moduleNames():
            self.__add_module_label(label)
        for label in self.cfg.pathNames():
            self.__add_path_label(label)
        self.__add_source_label(self.cfg.mainInputSource()['@classname'][2])
        self._esModuleLabels=dict()
        for label in self.cfg.esModuleNames():
            parts = label.split('@')
            newLabel = parts[0]
            if len(parts[1]) != 0:
                newLabel = parts[1]
            self._esModuleLabels[newLabel]=label
            self.__add_es_module_label(newLabel)
        self._esSourceLabels=dict()
        for label in self.cfg.esSourceNames():
            parts = label.split('@')
            newLabel = parts[0]
            if len(parts[1]) != 0:
                newLabel = parts[1]
            self._esSourceLabels[newLabel]=label
            self.__add_es_source_label(newLabel)


    def do__read(self,line):
        """Description: Read in the configuration file
        Commands:
        _read <filename>  reads the configuration file <filename>"""
        try:
            txt = file(line).read()
            parsedTxt = os.popen("EdmConfigToPython < "+line).read()
            self.__parse_pycfg(parsedTxt)
            self.prompt = os.path.basename(line)+'>'
        except Exception, e:
            print e
        else:
            self.__print_process_summary()
        #print self.get_names()

    def complete__read(self,text,line,begidx,endidx):
        space = line.rfind(' ',0,begidx);
        return [x[begidx-space-1:] for x in glob.glob(line[space+1:endidx]+"*")]
        
    def do_path(self,line,dummy=''):
        """Description: Show the configuration of a path
        Commands:
        path         list all path labels in the configuration
        path <pth>   prints the description of the path <pth> """
        if not self.cfg:
            print "no configuration has been read"
            return
        if 0 == len(line):
            self.__print_paths()
        else:
            try:
                self.__print_path(line)
            except BadLabelException, e:
                print "no path named '"+e.label+"'"

    def __print_paths(self):
        """Print the list of path labels"""
        if self.cfg:
            paths = self.cfg.pathNames()
            paths.sort()
            self.columnize(paths)
            
    def __print_path(self,pathName):
        """Prints the configuration of just one path"""
        if self.cfg:
            try:
                print "path: "+self.cfg.path(pathName)
            except KeyError:
                raise BadLabelException(pathName)
            
    def do_quit(self,line):
        """Description: quit application"""
        return True

    def __print_process_summary(self):
        """print a high level overview of the job configuration"""
        print "---Process Summary---"
        print "process: "+self.cfg.procName()
        print "source: "+self.cfg.mainInputSource()['@classname'][2]
        print "module:"
        self.do_module('')
        print "path:"
        self.do_path('')
        if len(self._esModuleLabels) != 0:
            print "es_module:"
            self.do_es_module('')
        if len(self._esSourceLabels) != 0:
            print "es_source:"
            self.do_es_source('')
        
    def __print_pset(self,psetDict,indent):
        """print the contents of a pset"""
        keys = psetDict.keys()
        keys.sort()
        for key in keys:
            param = psetDict[key]
            #do not print hidden framework values
            if '@' == key[0]: continue
            value = param[2]
            if 'VPSet' == param[0]:
                print indent+param[1]+" "+param[0]+" "+key+" ="
                for i in value:
                    print indent+' {'
                    self.__print_pset(i,indent+"  ")
                    print indent+' }'
                continue            
            if 'v'==param[0][0]:
                value = ''
                for i in param[2]:
                    value +=i+" "
            if 'PSet' == param[0]:
                print indent+param[1]+" "+param[0]+" "+key+" ="
                self.__print_pset(param[2],indent+"  ")
                continue
            print indent+param[1]+" "+param[0]+" "+key+" = "+value

    def __print_source(self,dummy='',line=''):
        if 0 == len(line):
            print "source: "+self.cfg.mainInputSource()['@classname'][2]
            self.__print_pset(self.cfg.mainInputSource(),"  ")
        else:
            self.__print_pset_param(self.cfg.mainInputSource()['@classname'][2],line,self.cfg.mainInputSource())

    def __print_module(self,label,line=''):
        try:
            info = self.cfg.module(label)
        except KeyError:
            raise BadLabelException(label)

        if 0 == len(line):
            print "module: "+info['@classname'][2]
            self.__print_pset(info,"  ")
        else:
            self.__print_module_param(label,line)

    def __print_param_value(self,param):
        if param[0] == 'PSet':
            print '('+param[1]+' '+param[0]+')'
            self.__print_pset(param[2],'  ')
            return
        value = param[2]
        if 'VPSet' == param[0]:
            print '('+param[1]+" "+param[0]+")"
            for i in value:
                print ' {'
                self.__print_pset(i,"  ")
                print ' }'
            return            
        if param[0][0] == 'v':
            value = ''
            for i in param[2]:
                value +=i+" "
        print "("+param[1]+" "+param[0]+") "+value
        
    def __print_module_param(self,label,line):
        self.__print_pset_param(label,line,self.cfg.module(label))
     
    def __print_pset_param(self,label,line,psetDict):
        labels = line.split('.')
        if 2 > len(labels):
            return
        if not labels[1] in psetDict:
            print 'the module '+label+' has no parameter '+labels[1]
            return
        param = psetDict[labels[1]]
        depth = label+'.'+labels[1]
        for x in labels[2:]:
            if param[0] != 'PSet':
                print 'the label '+depth+' is a '+param[0]+' not a PSet so has no sub labels'
                return
            if not x in param[2]:
                print 'the label '+depth+' has no sub label '+x
                return
            param = param[2][x]            
        self.__print_param_value(param)
        
    def __add_module_label(self,label):
        """create new commands for the new module label"""
        self.__add_new_label(label,CmsBuilder.__module_help,CmsBuilder.__print_module,CmsBuilder.__module_complete)

    def __module_complete(self,label,text,line,begidx,endidx):
        """gives list of completions possible for this label"""
        mod = self.cfg.module(label)
        return self.__pset_complete(label,mod,text,line,begidx,endidx)

    def __module_help(self,label):
        self.__pset_help(label,'module')

    def __add_es_module_label(self,label):
        """create new commands for the new es_module label"""
        self.__add_new_label(label,CmsBuilder.__es_module_help,CmsBuilder.__print_es_module,CmsBuilder.__es_module_complete)

    def __es_module_complete(self,label,text,line,begidx,endidx):
        """gives list of completions possible for this label"""
        mod = self.__find_es_module(label)
        return self.__pset_complete(label,mod,text,line,begidx,endidx)

    def __es_module_help(self,label):
        self.__pset_help(label,'es_module')

    def __add_es_source_label(self,label):
        """create new commands for the new es_source label"""
        self.__add_new_label(label,CmsBuilder.__es_source_help,CmsBuilder.__print_es_source,CmsBuilder.__es_source_complete)

    def __es_source_complete(self,label,text,line,begidx,endidx):
        """gives list of completions possible for this label"""
        mod = self.__find_es_source(label)
        return self.__pset_complete(label,mod,text,line,begidx,endidx)

    def __es_source_help(self,label):
        self.__pset_help(label,'es_source')

    def __add_source_label(self,label):
        """create new commands for the new module label"""
        self.__add_new_label(label,CmsBuilder.__source_help,CmsBuilder.__print_source,CmsBuilder.__source_complete)

    def __source_complete(self,label,text,line,begidx,endidx):
        """gives list of completions possible for this label"""
        mod = self.cfg.mainInputSource()
        return self.__pset_complete(label,mod,text,line,begidx,endidx)

    def __source_help(self,label):
        self.__pset_help(label,'source')

    def __path_help(self,label):
        print "Description: retrieve information about path "+label
        print "Commands:"
        print label+"    prints path description"
    
    def __pset_help(self,label,lType):
        print "Description: retrieve information about "+lType+" "+label
        print "Commands:"
        print label+"          prints "+lType+" description"
        print label+".<param>  prints value of parameter <param>"

    def __pset_complete(self,label,paramDict,text,line,begidx,endidx):
        if line[len(label)] != '.':
            return []
        labels = line[len(label)+1:begidx].split('.')
        for x in labels:
            if x == '':
                continue
            if not x in paramDict:
                return []
            paramDict = paramDict[x][2]
        match = text
        matchLen = len(match)
        return [ x for x in paramDict.keys() if match==x[0:matchLen] and x[0]!='@']

    def __add_new_label(self,label,helpType,doType,completeType):
        """create new commands for the new label"""
        def label_do(self,line): doType(self,label,line)
        CmsBuilder.__dict__['do_'+label]=label_do
        def label_help(self): helpType(self,label)
        CmsBuilder.__dict__['help_'+label]=label_help
        def label_complete(self,text,line,begidx,endidx): return completeType(self,label,text,line,begidx,endidx)
        CmsBuilder.__dict__['complete_'+label]=label_complete
        self.addedCommands.append(label)

    def __remove_labels(self):
        """removes commands that are no longer needed"""
        for l in self.addedCommands:
            del CmsBuilder.__dict__['do_'+l]
            del CmsBuilder.__dict__['help_'+l]
            del CmsBuilder.__dict__['complete_'+l]
        self.addedCommands = list()

    def __add_path_label(self,label):
        """create new commands for the new path label"""
        self.__add_new_label(label,CmsBuilder.__path_help,CmsBuilder.do_path,CmsBuilder.__path_complete)

    def __path_complete(self,label,text,line,begidx,endidx):
        #print '"'+text+'"'
        return []
    
    def complete_path(self,text,line,begidx,endidx):
        #if the separator is not a space then no match
        # note: 4 is the length of the string 'path'
        if line[4] != ' ':
            return []
        r = re.compile(text+'.*')
        return [x for x in self.cfg.pathNames() if r.match(x) ]

if __name__=="__main__":
    import sys
    import optparse
    
    usage = "%prog [options] [configuration file name]"
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("--test", action="store_true", dest="test", default=False, help="run the builtin application tests")
    (options,args) = parser.parse_args()
    if options.test :
        print "run tests"
        import unittest
        import tempfile
        
        class PrintIntercept:
            def __init__(self):
                self.__lastPrint = ""
            def lastPrint(self):
                return self.__lastPrint
            def write(self,info):
                self.__lastPrint += info
            def clear(self):
                self.__lastPrint=""
        
        class TestModuleCommand(unittest.TestCase):
            def setUp(self):
                self.stdout = sys.stdout
                self.__printIntercept = PrintIntercept()
                sys.stdout = self.__printIntercept
                testFile = tempfile.NamedTemporaryFile()
                testFile.write("""process TEST = {
                                 source = ASource { untracked int32 maxEvents = -1 }
                                 module b = BProd { string st = "st" }
                                 module c = CProd { }
                                 module c2  = CProd {}
                                 es_source = ESSource1 { }
                                 es_source = ESSource2 {}
                                 es_source ess1 = ESSource1 {}
                                 es_module esm1 = ESProd {}
                                 es_module = ESProd2 {}
                               }""")
                testFile.flush()
                self.__info = {'source':(('ASource',{'maxEvents':('untracked','int32','-1')}),),
                                'module':(('b',{'st':('tracked','string',"st")}),('c',{}),('c2',{})),
                                'es_source':(('ESSource1',{}),('ESSource2',{}),('ess1',{})),
                                'es_module':(('esm1',{}),('ESProd2',{}))}
                #self.stdout.write(testFile.name)
                self.__builder = CmsBuilder("")
                self.__builder.do__read(testFile.name)
                return
            def __reset(self):
                self.__printIntercept.clear()
            def testNoFile(self):
                builder = CmsBuilder("")
                fileName = "/bad/doesNotExist"
                builder.do__read(fileName)
                try:
                    self.assertNotEqual(-1,self.__printIntercept.lastPrint().find(fileName))
                finally:
                    self.__reset()
            def __checkForLabelAndValues(self,labelValueString,label,values):
                    return labelValueString.find(label)
            def testdolist(self):
                for type in self.__info.keys():
                    exec ("self._TestModuleCommand__builder.do_"+type+"('')")
                    try:
                        for info in self.__info[type]:
                            #sys.stderr.write( "info " + str(info) )
                            #sys.stderr.flush()
                            name = info[0]
                            self.assertNotEqual(-1,self.__printIntercept.lastPrint().find(name))
                    finally:
                        self.__reset()
                    #check for each module that it has the proper data
                    if type == "source":
                        continue
                    for info in self.__info[type]:
                        name = info[0]
                        exec("self._TestModuleCommand__builder.do_"+type+"('"+name+"')")
                        try:
                            for label in info[1].keys():
                                self.assertNotEqual(-1,
                                                    self.__checkForLabelAndValues(self.__printIntercept.lastPrint(),
                                                                                  label,
                                                                                  info[1][label]))
                        finally:
                            self.__reset()
                        #also try just the label as a command
                        exec("self._TestModuleCommand__builder.do_"+name+"('')")
                        try:
                            for label in info[1].keys():
                                self.assertNotEqual(-1,
                                                    self.__checkForLabelAndValues(self.__printIntercept.lastPrint(),
                                                                                  label,
                                                                                  info[1][label]))
                        finally:
                            self.__reset()
            def testcompletelist(self):
                for type in self.__info.keys():
                    if type == 'source':
                        continue
                    length = str(0)
                    result = eval ("self._TestModuleCommand__builder.complete_"+type+"('','"+type+" ',"+length+","+length+")")
                    try:
                        for info in self.__info[type]:
                            name = info[0]
                            success=False
                            try:
                                self.assert_(name in result)
                                success=True
                            finally:
                                if not success :
                                    sys.stderr.write("completions:"+str(result)+" type :"+type+" name: "+name)
                    finally:
                        self.__reset()
                    #now try each one individual trying a different length for the text
                    for info in self.__info[type]:
                        name = info[0]
                        for index in range(1,len(name[0])):
                            length = str(index)
                            result = eval( "self._TestModuleCommand__builder.complete_"+type+"('"+name[0:index]+"','"+type+" ',"+length+","+length+")")
                            success= False
                            try:
                                self.assert_(name in result)
                                success=True
                            finally:
                                if not success:
                                    sys.stderr.write("prefix:"+name[0:index]+" completions:"+str(result)+" type :"+type+" name: "+name)
                                self.__reset()
            def testcompletemodule(self):
                for type in self.__info.keys():
                    for info in self.__info[type]:
                        name = info[0]
                        length = str(0)
                        result = eval("self._TestModuleCommand__builder.complete_"+name+"('','"+name+".',"+length+","+length+")")
                        try:
                            for label in info[1].keys():
                                success=False
                                try:
                                    self.assert_(label in result)
                                    success=True
                                finally:
                                    if not success:
                                        sys.stderr.write("completions:"+str(result)+" object: "+name+" label: "+label)
                        finally:
                            self.__reset()

                    

        #the test system also reads the command line options so I must remove '--test'
        sys.argv.remove("--test")
        
        unittest.main()
        sys.exit(0)
    fileName=""
    if 1 < len(args):
        parser.error("incorrect number of arguments")

    print "Type 'help' or press 'TAB' twice to get a list of commands"
    if 1 == len(args):
        fileName=args[0]
    else:
        print "use '_read <filename>' to read a configuration file"
    CmsBuilder(fileName).cmdloop()
