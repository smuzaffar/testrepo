/*----------------------------------------------------------------------
$Id: EventStreamInput.cc,v 1.12 2005/10/16 17:47:03 wmtan Exp $
----------------------------------------------------------------------*/

#include "IOPool/Streamer/interface/EventStreamInput.h"
#include "IOPool/StreamerData/interface/StreamedProducts.h"
#include "IOPool/Streamer/interface/ClassFiller.h"
#include "IOPool/Streamer/interface/Utilities.h"

#include "FWCore/EDProduct/interface/EDProduct.h"
#include "FWCore/Utilities/interface/DebugMacros.h"
#include "FWCore/Framework/interface/BranchKey.h"
#include "FWCore/Framework/interface/EventAux.h"
#include "FWCore/Framework/interface/EventPrincipal.h"
#include "FWCore/Framework/interface/EventProvenance.h"
#include "FWCore/Framework/interface/ProductRegistry.h"
#include "FWCore/Framework/interface/InputSourceDescription.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include <iostream>
#include <cassert>

using namespace std;

namespace edm
{

  EventStreamerInputImpl::EventStreamerInputImpl(ParameterSet const&,
						 InputSourceDescription const& desc,
						 EventBuffer* bufs) :
    regbuf_(1000*1000),
    bufs_(bufs),
    pr_(desc.preg_),
    send_event_(),
    prog_reg_(),
    state_(Init)
  {
    loadExtraClasses();
    init();

    prog_reg_ = getTClass(typeid(SendJobHeader));
    send_event_ = getTClass(typeid(SendEvent));

    if(!prog_reg_)
      throw cms::Exception("Init","EventStreamer")
	<< "Could not get the TClass for the SendJobHeader type\n";
    if(!send_event_)
      throw cms::Exception("Init","EventStreamer")
	<< "Could not get the TClass for the SendEvent type\n";
  }

  void EventStreamerInputImpl::init()
  {
  }

  // decode the message that is supposed to be already present in the
  // registry buffer
  void EventStreamerInputImpl::decodeRegistry()
  {
    InitMsg msg(&regbuf_[0],regbuf_.size());
    this->decodeRegistry(msg);
  }

  void EventStreamerInputImpl::decodeRegistry(const InitMsg& msg)
  {
    std::auto_ptr<SendJobHeader> sd(decodeJobHeader(msg));
    if(state_!=Init)
      {
	if(registryIsSubset(*(sd.get()),*pr_)==false)
	  throw cms::Exception("InconsistentRegistry","EventStreamer")
	    << "A new product registry was received during the "
	    << "running state with entries that were not present "
	    << "in the original registry.\n";
      }
    else
      {
	mergeWithRegistry(*(sd.get()),*pr_);
      }
  }

  EventStreamerInputImpl::~EventStreamerInputImpl()
  {
  }

  // reconstitute() is responsible for creating, and setting up, the
  // EventPrincipal.
  //
  // All products are reconstituted.

  auto_ptr<EventPrincipal>
  EventStreamerInputImpl::reconstitute()
  {
    assert(send_event_!=0);
    bool got_event=false;
    auto_ptr<EventPrincipal> ep;

    while(got_event==false)
      {
	EventBuffer::ConsumerBuffer pb(*bufs_);

	// the current trigger for end of processing is a zero length
	// message.  This will probably not work when the protocol gets more
	// complex - we need to use the "endnow" message instead.	
	if(pb.size()==0) { got_event=true; continue; }

	MsgCode msg(pb.buffer(),pb.size());

	if(msg.getCode() == MsgCode::EVENT)
	  {
	    ep = doOneEvent(msg);
	    got_event=true;
	  }
	else if(msg.getCode() == MsgCode::INIT)
	  {
	    InitMsg imsg(msg);
	    decodeRegistry(imsg);
	  }
      }

    return ep;
  }

  auto_ptr<EventPrincipal>
  EventStreamerInputImpl::doOneEvent(const EventMsg& msg)
  {
    auto_ptr<EventPrincipal> ep(decodeEvent(msg,*pr_));
    return ep;
  }
}
